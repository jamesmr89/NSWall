<?php
/*
	$Id: filter.inc,v 1.137 2009/04/20 17:51:02 jrecords Exp $
	part of m0n0wall (http://m0n0.ch/wall)
	
	Copyright (C) 2003-2006 Manuel Kasper <mk@neon1.net>.
	All rights reserved.
	
	Redistribution and use in source and binary forms, with or without
	modification, are permitted provided that the following conditions are met:
	
	1. Redistributions of source code must retain the above copyright notice,
	   this list of conditions and the following disclaimer.
	
	2. Redistributions in binary form must reproduce the above copyright
	   notice, this list of conditions and the following disclaimer in the
	   documentation and/or other materials provided with the distribution.
	
	THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
	INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
	AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
	AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
	OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
	SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
	INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
	CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
	ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
	POSSIBILITY OF SUCH DAMAGE.
*/
	
/* include all configuration functions */
require_once("functions.inc");

/* returns the ruleset number for the anchorname */
function filter_get_anchornumber($rule) {
	$pfrules = `/sbin/pfctl -vvs rules`;
        $pfrules = split("\n", $pfrules);
        foreach ($pfrules as $line) {
                $pattern = "/^\@(\d+)\sanchor\s\"$rule\"/";
                if (preg_match_all($pattern, $line, $matches)) {
                        return($matches[1][0]);
                }
        }
}

function filter_pad_comments($string) {
	$length = strlen($string);
	for($i=0;$i<$length + 8;$i++) {
		$retval .= '#';
	}
	return $retval;
}

function filter_print_pfconf() {
	printf("########################################\n");
	printf("### pf.conf file generated by NSWall ###\n"); 
	printf("########################################\n\n");
	$natrules = filter_nat_rules_generate();
	$rdrrules = filter_rdrrules_generate();
	$pfrules = htmlentities(filter_rules_generate());
	$altqconf = altq_conf_generate();
	$aliasrules = filter_aliasrules_generate();
	$pfoptions = filter_options_generate();
	$pfnormalization = filter_normalization_generate();
	$tables = htmlentities(filter_tables_generate());
	printf("$tables");
	printf("$aliasrules");
        printf("$pfoptions\n");
	printf("$pfnormalization\n");
        printf("$altqconf\n");
	printf("$rdrrules\n");
	printf("$natrules\n");
	printf("$pfrules\n");
}

function filter_generate_multiwan_interfaces() {
	global $config, $g;
     	if (isset($config['system']['multiwan'])) {
		$wanifs = array(); 
        	array_push($wanifs, get_real_wan_interface());
        	for ($i = 1; isset($config['interfaces']['opt' . $i]); $i++) {
                	$oc = $config['interfaces']['opt' . $i];
                	if (isset($oc['enable']) && $oc['if']) {
                        	if($oc['type'] == 'WAN') {
                                	array_push($wanifs, $oc['if']);
                        	}
                	}
        	}
	}
        return $wanifs;
}

function filter_configure() {
	global $config, $g;
	
	if ($g['booting'])
		echo "Configuring Firewall... ";

	/* generate pf rules */
	$pfrules = filter_tables_generate();
	$pfrules .= filter_aliasrules_generate();
	$pfrules .= filter_options_generate();
	$pfrules .= filter_normalization_generate();
	$pfrules .= altq_conf_generate();
	$pfrules .= filter_nat_rules_generate();
	$pfrules .= filter_rdrrules_generate();
	$pfrules .= filter_rules_generate();
	
	/* load pf ruleset */
	if(isset($config['system']['pfdebug'])) {
		$fd = popen("/sbin/pfctl -Fn -Fq -Fr -FT -vv -f - > /tmp/pfctl.error", "w");
        	if (!$fd) {
                	printf("Cannot open /sbin/pfctl in filter_configure()\n");
                	return 1;
        	}

        	fwrite($fd, $pfrules);
        	pclose($fd);
 
  	        $debug_pfconf = fopen("/tmp/pf.conf.debug", "w+") or die("Couldn't create new file");
        	$pfconfdebug = preg_split('/\n/', $pfrules);
       	 	$i = 1;
		foreach($pfconfdebug as $line) {
	               	fwrite($debug_pfconf, "$i\t$line" . "\n");
        		$i++;
		}
        	fclose($debug_pfconf);

	} else {
		$fd = popen("/sbin/pfctl -Fn -Fq -Fr -FT -q -f - > /dev/null 2>&1", "w");
		if (!$fd) {
			printf("Cannot open /sbin/pfctl in filter_configure()\n");
			return 1;
		}
		
		fwrite($fd, $pfrules);
		pclose($fd);
	}

	if ($g['booting'])
		echo "done\n";
	
	return 0;

}

function filter_parse_config($config) {
        global $config;
        
        /* generate pf rules */
        $pfrules = filter_tables_generate();
	$pfrules .= filter_aliasrules_generate();
        $pfrules .= filter_options_generate();
        $pfrules .= filter_normalization_generate();
        $pfrules .= altq_conf_generate();
        $pfrules .= filter_nat_rules_generate();
        $pfrules .= filter_rdrrules_generate();
        $pfrules .= filter_rules_generate();
        
        $descriptorspec = array(
        0 => array("pipe", "r"),  // stdin is a pipe that the child will read from
        1 => array("pipe", "w"),  // stdout is a pipe that the child will write to
        2 => array("pipe", "w") // stderr is a file to write to
        );

        /* load pf ruleset */
        $process = proc_open("/sbin/pfctl -gnf -", $descriptorspec, $pipes );
        if (is_resource($process)) {
        // $pipes now looks like this:
        // 0 => writeable handle connected to child stdin
        // 1 => readable handle connected to child stdout
        // Any error output will be appended to /tmp/error-output.txt

        fwrite($pipes[0], $pfrules);
        fclose($pipes[0]);
        while (!feof($pipes[2])) {
                $out .=  fgets($pipes[2], 128); 
        }
        fclose($pipes[2]);
        }
        $return_value = proc_close($process);

        if($return_value) {      
                $errors = preg_split("/stdin:/", $out);
                foreach($errors as $error) {
                        mwexec("/usr/bin/logger -p local0.info -t configparse $error");
                }
        }
        return $return_value;
}

function filter_enable_pf() {
	global $config, $g;

	if ($g['booting'])
                echo "Enabling PF... ";
	
	mwexec("/sbin/pfctl -e");
	
	if ($g['booting'])
                echo "done\n";
}

function filter_flush_nat_table() {
	global $config, $g;
	
	return mwexec("/sbin/pfctl -F nat");
}

function filter_flush_state_table() {
	global $config, $g;
	
	return mwexec("/sbin/pfctl -F statesS");
}

function filter_nat_rules_generate_if($if, $src, $dst, $target, $portmap = true) {
        $natrule .= "nat on $if from $src $dst -> ($if)\n";
        return $natrule;
}

function filter_tables_generate() {
	 global $config, $g;

    $line = <<<EOD

################
#### Tables  ###
################
table <abusive_hosts> persist

#############
### Users ###
#############

EOD;
	if (is_array($config['system']['accounts']['user'])) {
		foreach ($config['system']['accounts']['user'] as $user) {
			$line .= 'table <' . $user['name'] . '> persist' . "\n";
		}
	} 

$line .= <<<EOD

##############
### Groups ###
##############

EOD;

	if (is_array($config['system']['accounts']['group'])) {
                foreach ($config['system']['accounts']['group'] as $group) {
                        $line .= 'table <' . $group['name'] . '> persist' . "\n";
                }
        }

 	$line .= "\n";
	
	return $line;
}

function filter_aliasrules_generate() {
        global $config, $g;
                $line = "###############\n";
		$line .= "### Aliases ###\n";
		$line .= "###############\n";
                $line .= filter_system_aliases_generate();
		if (isset($config['aliases']['alias'])) {
			foreach ($config['aliases']['alias'] as $alias) {
                        	unset($recursive);
                       	 	if (isset($alias['memberlist'])) {
                                	$memberlist = $alias['memberlist'];
                                	for($i=0;$i<sizeof($memberlist); $i++) {
                                        	$mem = "member" . "$i";
                                        	if(preg_match('/^\$/', $memberlist[$mem]))
                                                	$recursive = 'TRUE';
                                	}
                                	$line .= $alias['name'] . ' =' .  " \"";
                                	if(sizeof($memberlist) != '1')
                                        	$line .= "{";
                                	if($recursive == 'TRUE')
                                        	$line .= '" ';
                                	for($i=0;$i<sizeof($memberlist); $i++) {
                                        	$mem = "member" . "$i";
                                        	$line .= "$memberlist[$mem] ";
                                	}
                                	$line = preg_replace('/ $/', '', $line);
                                	if($recursive == 'TRUE')
                                        	$line .= ' "';
                                	if(sizeof($memberlist) != '1')
                                        	$line .= "}";
                        	}
                	$line .= '"';
                        $line .= "\n";
			}
		}
                $line .= "\n";
        return $line;
}

function filter_expand_alias($name) {
	global $config, $g;
	if (isset($config['aliases']['alias'])) {                        
		foreach ($config['aliases']['alias'] as $alias) {
			if($alias['name'] == $name) {
				if (isset($alias['memberlist'])) {
        				$memberlist = $alias['memberlist'];
        				for($i=0;$i<sizeof($memberlist); $i++) {
        					$mem = "member" . "$i";
        					$string .= "$memberlist[$mem] ";
        				}
        				$string = preg_replace('/ $/', '', $string);
        			}
			}
		}
	}
	return $string;
}

function filter_nat_rules_generate() {
	global $config, $g;
	
	$wancfg = $config['interfaces']['wan'];
	$lancfg = $config['interfaces']['lan'];
	
	$pptpdcfg = $config['pptpd'];
	$wanif = get_real_wan_interface();
	
	$lansa = gen_subnet($lancfg['ipaddr'], $lancfg['subnet']);
	
	$natrules = "#################\n";
	$natrules .= "### NAT rules ###\n";
	$natrules .= "#################\n";	

	/* any 1:1 mappings? */
	if (is_array($config['nat']['onetoone'])) {
		foreach ($config['nat']['onetoone'] as $natent) {
			if (!is_numeric($natent['subnet']))
				$sn = 32;
			else
				$sn = $natent['subnet'];
			
			if (!$natent['interface'] || ($natent['interface'] == "wan"))
				$natif = $wanif;
			else
				$natif = $config['interfaces'][$natent['interface']]['if'];
			
			$natrules .= "binat on {$natif} from {$natent['internal']} to any -> {$natent['external']}\n";
		}
	}
	/* we will always have the nat anchors for ftp */
                $natrules .= 'nat-anchor "ftp-proxy/*"' . "\n";
		
		/* Dynamic outbound rules - advanced or standard */
                if (is_array($config['nat']['advancedoutbound']['rule'])) {
                        foreach ($config['nat']['advancedoutbound']['rule'] as $obent) {
                                $dst = "to any";
                                $src = "";
                                if (!isset($obent['destination']['any'])) {
                                        if (isset($obent['destination']['not']))
                                                $dst = "! to ";
                                        else
                                                $dst = "to ";
                                        $dst .= $obent['destination']['network'];
                                }
                                $src .= $obent['source']['network'];

                                if (!$obent['interface'] || ($obent['interface'] == "wan"))
                                        $natif = $wanif;
                                elseif ($obent['interface'] == "pptp")
                                        $natif = 'tun0';
                                else
                                        $natif = $config['interfaces'][$obent['interface']]['if'];

                                $natrules .= filter_nat_rules_generate_if($natif, $src, $dst,
                                        $obent['target'], !isset($obent['noportmap']));
                        }
                }

	if (isset($config['pptp']['client']['autonat']))
        	$natrules .= "nat on tun0 from any to any -> (tun0)\n";

	/* DIAG: add ipv6 NAT, if requested */
	if (isset($config['diag']['ipv6nat']['enable'])) {
		$natrules .= "rdr $wanif 0/0 port 0 -> " . 
		"{$config['diag']['ipv6nat']['ipaddr']} port 0 ipv6\n";
	}
	
	if (isset($config['nat']['rule'])) {
		foreach ($config['nat']['rule'] as $rule) {
		
			$extport = explode("-", $rule['external-port']);
			$target = alias_expand_host($rule['target']);
			
			if (!$target)
				continue;	/* unresolvable alias */
			
			if ($rule['external-address'])
				$extaddr = $rule['external-address'] . "/32";
			else
				$extaddr = "0/0";
			
			if (!$rule['interface'] || ($rule['interface'] == "wan"))
				$natif = $wanif;
			else
				$natif = $config['interfaces'][$rule['interface']]['if'];
			
			if ((!$extport[1]) || ($extport[0] == $extport[1])) {
				$natrules .=
					"rdr $natif {$extaddr} port {$extport[0]} -> {$target} " .
					"port {$rule['local-port']} {$rule['protocol']}";
			} else {
				$natrules .=
					"rdr $natif {$extaddr} port {$extport[0]}-{$extport[1]} " .
					"-> {$target} " .
					"port {$rule['local-port']} {$rule['protocol']}";
			}
				
			$natrules .= "\n";
		}
	}
	
	if ($pptpdcfg['mode'] == "redir" && $pptpdcfg['redir']) {
	
		$natrules .= <<<EOD

# PPTP
rdr $wanif 0/0 port 0 -> {$pptpdcfg['redir']} port 0 gre
rdr $wanif 0/0 port 1723 -> {$pptpdcfg['redir']} port 1723 tcp

EOD;
	}
	
	return $natrules;
}

function altq_conf_generate() {
        global $config, $g;
	if (isset($config['altq']['enable'])) {
        	$wancfg = $config['interfaces']['wan'];
        	$lancfg = $config['interfaces']['lan'];
        	$bandwidth = $config['altq']['bandwidth'] . "Kb";
       	 	$lanif = $lancfg['if'];
        	$wanif = get_real_wan_interface();
        	$altqconf = "#####################\n";
		$altqconf .= "### ALTQ settings ###\n";
		$altqconf .= "#####################\n";
		$altqconf .= "altq on $wanif priq bandwidth $bandwidth queue { ackout, highest, high, medium, low }\n"; 
        	$altqconf .= "queue ackout	 priority 4\n";
		$altqconf .= "queue highest	 priority 3\n";
        	$altqconf .= "queue high 	 priority 2\n";
        	$altqconf .= "queue medium 	 priq(default)\n";
        	$altqconf .= "queue low	 priority 0\n";

        	return $altqconf;
	}
}

function filter_options_generate() {
        global $config;
	$pfglobals = "#########################\n";
	$pfglobals .= "### Global PF Options ###\n";
	$pfglobals .= "#########################\n";
	$pfglobals .= "set skip on lo0\n";
	$pfglobals .= "set loginterface " . $config['interfaces']['wan']['if'] . "\n";
        if (isset($config['filter']['options']['timeouts']['tcpfirst']))
        	$pfglobals .= "set timeout tcp.first " . $config['filter']['options']['timeouts']['tcpfirst'] . "\n";       
 	if (isset($config['filter']['options']['timeouts']['tcpopening']))
                $pfglobals .= "set timeout tcp.opening " . $config['filter']['options']['timeouts']['tcpopening'] . "\n";    
	if (isset($config['filter']['options']['timeouts']['tcpestablished']))
                $pfglobals .= "set timeout tcp.established " . $config['filter']['options']['timeouts']['tcpestablished'] . "\n";    
	if (isset($config['filter']['options']['timeouts']['tcpclosing'])) 
                $pfglobals .= "set timeout tcp.closing " . $config['filter']['options']['timeouts']['tcpclosing'] . "\n";    
	if (isset($config['filter']['options']['timeouts']['tcpfinwait'])) 
                $pfglobals .= "set timeout tcp.finwait " . $config['filter']['options']['timeouts']['tcpfinwait'] . "\n";    		
	if (isset($config['filter']['options']['timeouts']['tcpclosed'])) 
                $pfglobals .= "set timeout tcp.closed " . $config['filter']['options']['timeouts']['tcpclosed'] . "\n";    
	if (isset($config['filter']['options']['timeouts']['udpfirst']))
                $pfglobals .= "set timeout udp.first " . $config['filter']['options']['timeouts']['udpfirst'] . "\n";	
	if (isset($config['filter']['options']['timeouts']['udpsingle']))
                $pfglobals .= "set timeout udp.single " . $config['filter']['options']['timeouts']['udpsingle'] . "\n";
        if (isset($config['filter']['options']['timeouts']['udpmultiple']))
                $pfglobals .= "set timeout icmp.first " . $config['filter']['options']['timeouts']['icmpfirst'] . "\n";        
	if (isset($config['filter']['options']['timeouts']['icmperror']))
                $pfglobals .= "set timeout icmp.error " . $config['filter']['options']['timeouts']['icmperror'] . "\n";
	if (isset($config['filter']['options']['timeouts']['otherfirst']))
                $pfglobals .= "set timeout other.first " . $config['filter']['options']['timeouts']['otherfirst'] . "\n";
	if (isset($config['filter']['options']['timeouts']['othersingle']))
                $pfglobals .= "set timeout other.single " . $config['filter']['options']['timeouts']['othersingle'] . "\n";
	if (isset($config['filter']['options']['timeouts']['othermultiple']))
                $pfglobals .= "set timeout other.multiple " . $config['filter']['options']['timeouts']['othermultiple'] . "\n";
	if (isset($config['filter']['options']['timeouts']['adaptivestart']))
                $pfglobals .= "set timeout adaptive.start " . $config['filter']['options']['timeouts']['adaptivestart'] . "\n";
	if (isset($config['filter']['options']['timeouts']['adaptivestop']))
                $pfglobals .= "set timeout adaptive.end " . $config['filter']['options']['timeouts']['adaptivestop'] . "\n";
	if (isset($config['filter']['options']['limits']['maxstates']))
                $pfglobals .= "set limit states " . $config['filter']['options']['limits']['maxstates'] . "\n";
	if (isset($config['filter']['options']['limits']['maxfrags']))
                $pfglobals .= "set limit frags " . $config['filter']['options']['limits']['maxfrags'] . "\n";
	if (isset($config['filter']['options']['limits']['srcnodes']))
                $pfglobals .= "set limit src-nodes " . $config['filter']['options']['limits']['srcnodes'] . "\n";
	if (isset($config['filter']['options']['opt']['rulesetopt']))
                $pfglobals .= "set ruleset-optimization " . $config['filter']['options']['opt']['rulesetopt'] . "\n";
        if (isset($config['filter']['options']['opt']['stateopt']))
                $pfglobals .= "set optimization " . $config['filter']['options']['opt']['stateopt'] . "\n";
        if (isset($config['filter']['options']['opt']['blockpol']))
                $pfglobals .= "set block-policy " . $config['filter']['options']['opt']['blockpol'] . "\n";
        if (isset($config['filter']['options']['opt']['statepol']))
                $pfglobals .= "set state-policy " . $config['filter']['options']['opt']['statepol'] . "\n";
	#$pfglobals .= "set skip on lo0\n";

	return $pfglobals;
}

function filter_normalization_generate() {
        global $config, $g;
        $ipfrules = <<<EOD
#############################
### Traffic Normalization ###
#############################
EOD;

        if (isset($config['filter']['options']['scrub']['dfbit']))
                $normalrule .= "no-df ";
        if (isset($config['filter']['options']['scrub']['minttl']))
                $normalrule .= "min-ttl " . $config['filter']['options']['scrub']['minttl'] . " ";
        if (isset($config['filter']['options']['scrub']['maxmss']))
                $normalrule .= "max-mss " . $config['filter']['options']['scrub']['maxmss'] . " ";
        if (isset($config['filter']['options']['scrub']['randid']))
                $normalrule .= "random-id ";
        if (isset($config['filter']['options']['scrub']['reassembletcp']))
                $normalrule .= "reassemble tcp";
        if ($normalrule)
        	$ipfrules .= "\nmatch in all scrub ( " . $normalrule . ")\n";

return $ipfrules;
}

function filter_system_aliases_generate() {
	global $config, $g;

        $lancfg = $config['interfaces']['lan'];
        
	$optcfg = array();

        for ($i = 1; isset($config['interfaces']['opt' . $i]); $i++) {
                $oc = $config['interfaces']['opt' . $i];

                if (isset($oc['enable']) && $oc['if']) {
                        $oic = array();
                        $oic['if'] = $oc['if'];

                        if ($oc['bridge']) {
                                if (!strstr($oc['bridge'], "opt") ||
                                         isset($config['interfaces'][$oc['bridge']]['enable'])) {
                                        if (is_ipaddr($config['interfaces'][$oc['bridge']]['ipaddr'])) {
                                                $oic['ip'] = $config['interfaces'][$oc['bridge']]['ipaddr'];
                                                $oic['sn'] = $config['interfaces'][$oc['bridge']]['subnet'];
                                                $oic['sa'] = gen_subnet($oic['ip'], $oic['sn']);
                                        	$oic['descr'] = $config['interfaces'][$oc['bridge']]['descr'];
					}
                                }
                                $oic['bridge'] = 1;
                                $oic['bridge_if'] = $oc['bridge'];
                        } else {
                		$oic['descr'] = $oc['descr'];
		                $oic['ip'] = $oc['ipaddr'];
                                $oic['sn'] = $oc['subnet'];
                                $oic['sa'] = gen_subnet($oic['ip'], $oic['sn']);
                        }

                        $optcfg['opt' . $i] = $oic;
                }
        }
	$sysalias_rules = 'RFC_1918 = "{ 192.168.0.0/16, 172.16.0.0/12, 10.0.0.0/8 }"' . "\n";
        $lansn = gen_subnet($lancfg['ipaddr'],$lancfg['subnet']);
 	$sysalias_rules .= 'LAN_IP = "' . $lancfg['ipaddr'] . "\"\n";
        $sysalias_rules .= 'LAN_Network = "' . $lansn .  '/' . $lancfg['subnet'] . "\"\n";

	for ($i = 1; isset($optcfg['opt' . $i]); $i++) {
        	$sysalias_rules .= $optcfg['opt' . $i]['descr'] . '_IP = "' . $optcfg['opt' . $i]['ip'] . "\"\n";
	        $sysalias_rules .= $optcfg['opt' . $i]['descr'] . '_Network = "' . $optcfg['opt' . $i]['ip'] . "/" . $optcfg['opt' . $i]['sn'] . '"' . "\n";
	}
	return $sysalias_rules;
}

function filter_system_aliases_names_generate() {
        global $config, $g;

        $lancfg = $config['interfaces']['lan'];

        $optcfg = array();

        for ($i = 1; isset($config['interfaces']['opt' . $i]); $i++) {
                $oc = $config['interfaces']['opt' . $i];

                if (isset($oc['enable']) && $oc['if']) {
                        $oic = array();
                        $oic['if'] = $oc['if'];

                        if ($oc['bridge']) {
                                if (!strstr($oc['bridge'], "opt") ||
                                         isset($config['interfaces'][$oc['bridge']]['enable'])) {
                                        if (is_ipaddr($config['interfaces'][$oc['bridge']]['ipaddr'])) {
                                                $oic['ip'] = $config['interfaces'][$oc['bridge']]['ipaddr'];
                                                $oic['sn'] = $config['interfaces'][$oc['bridge']]['subnet'];
                                                $oic['sa'] = gen_subnet($oic['ip'], $oic['sn']);
                                                $oic['descr'] = $config['interfaces'][$oc['bridge']]['descr'];
                                        }
                                }
                                $oic['bridge'] = 1;
                                $oic['bridge_if'] = $oc['bridge'];
                        } else {
                                $oic['descr'] = $oc['descr'];
                                $oic['ip'] = $oc['ipaddr'];
                                $oic['sn'] = $oc['subnet'];
                                $oic['sa'] = gen_subnet($oic['ip'], $oic['sn']);
                        }

                        $optcfg['opt' . $i] = $oic;
                }
        }
        $sysalias_rules = 'RFC_1918 ';
        $sysalias_rules .= 'LAN_IP ';
        $sysalias_rules .= 'LAN_Network ';

        for ($i = 1; isset($optcfg['opt' . $i]); $i++) {
                $sysalias_rules .= $optcfg['opt' . $i]['descr'] . '_IP ';
                $sysalias_rules .= $optcfg['opt' . $i]['descr'] . '_Network ';
        }
        $sysalias_rules = preg_replace("/\ $/", "", $sysalias_rules);
        return $sysalias_rules;
}

function filter_rules_generate() {
	global $config, $g;
	
	$wancfg = $config['interfaces']['wan'];
	$lancfg = $config['interfaces']['lan'];
	$pptpdcfg = $config['pptpd'];
	
	$lanif = $lancfg['if'];
	$wanif = get_real_wan_interface();
	
	$curwanip = get_current_wan_address();
	
	/* rule groups (optional interfaces: see below) */
	/*$ifgroups = array("lan" => 100, "wan" => 200);*/
	
	$lanip = $lancfg['ipaddr'];
	$lansa = gen_subnet($lancfg['ipaddr'], $lancfg['subnet']);
	$lansn = $lancfg['subnet'];
	
	/* optional interfaces */
	$optcfg = array();
	
	for ($i = 1; isset($config['interfaces']['opt' . $i]); $i++) {
		$oc = $config['interfaces']['opt' . $i];
		
		if (isset($oc['enable']) && $oc['if']) {
			$oic = array();
			$oic['if'] = $oc['if'];
			
			if ($oc['bridge']) {
				if (!strstr($oc['bridge'], "opt") || 
					 isset($config['interfaces'][$oc['bridge']]['enable'])) {
					if (is_ipaddr($config['interfaces'][$oc['bridge']]['ipaddr'])) {
						$oic['ip'] = $config['interfaces'][$oc['bridge']]['ipaddr'];
						$oic['sn'] = $config['interfaces'][$oc['bridge']]['subnet'];
						$oic['sa'] = gen_subnet($oic['ip'], $oic['sn']);
					}
				}
				$oic['bridge'] = 1;
				$oic['bridge_if'] = $oc['bridge'];
			} else {
				$oic['ip'] = $oc['ipaddr'];
				$oic['sn'] = $oc['subnet'];
				$oic['sa'] = gen_subnet($oic['ip'], $oic['sn']);
			}
			
			$optcfg['opt' . $i] = $oic;
			/*$ifgroups['opt' . $i] = ($i * 100) + 200;*/
		}
	}
	
	if ($pptpdcfg['mode'] == "server") {
		$pptpip = $pptpdcfg['localip'];
		$pptpsa = $pptpdcfg['remoteip'];
		$pptpsn = $g['pptp_subnet'];
	}
	
	/* default block logging? */
	if (isset($config['filter']['options']['logging']['default']))
		$log = 'log ';
	$defaultlog = $log . 'all';
	$ipfrules .= <<<EOD
#######################
#### Default Policy ###
#######################
anchor "default" {
	block in $defaultlog 
	pass out all
}

EOD;
	if($config['interfaces']['opt2']['wireless']['ifmode'] == 'lanbridge' || $config['interfaces']['opt2']['wireless']['ifmode'] == 'dmzbridge') {
 	$ipfrules .= <<<EOD

##############################################
### Allow all traffic into Wireless bridge ###
##############################################
anchor "Wireless_Bridge" {
	pass in quick on ral0 all
}

EOD;
	}
	$ipfrules .= <<<EOD

#######################################################
#### Activate spoofing protection on all interfaces ###
#######################################################
block in quick from urpf-failed

EOD;


	/* allow access to DHCP server on optional interfaces */
	foreach ($optcfg as $on => $oc) {
		if ((isset($config['dhcpd'][$on]['enable']) && !$oc['bridge']) ||
				($oc['bridge'] && isset($config['dhcpd'][$oc['bridge_if']]['enable']))) {
					
			$ipfrules .= <<<EOD

#############################################
### Allow access to DHCP server on {$on} ###
#############################################
pass in quick on {$oc['if']} proto udp from any port 68 to 255.255.255.255 port 67
pass in quick on {$oc['if']} proto udp from any port 68 to {$oc['ip']} port 67
pass out quick on {$oc['if']} proto udp from {$oc['ip']} port 67 to any port 68
\n\n
EOD;
		}
	}
	
	/* pass traffic between statically routed subnets and the subnet on the
	   interface in question to avoid problems with complicated routing
	   topologies */
	if (is_array($config['staticroutes']['route']) && count($config['staticroutes']['route'])) {
		$ipfrules .= "\n###########################################\n";
		$ipfrules .= "\n### Allow traffic from/to static routes ###\n";
		$ipfrules .= "\n###########################################\n";
		foreach ($config['staticroutes']['route'] as $route) {
			unset($sa);
			
			if ($route['interface'] == "lan") {
				$ip = $lanip;
				$sa = $lansa;
				$sn = $lansn;
				$if = $lanif;
			} else if (strstr($route['interface'], "opt")) {
				$oc = $optcfg[$route['interface']];
				if ($oc['ip']) {
					$ip = $oc['ip'];
					$sa = $oc['sa'];
					$sn = $oc['sn'];
					$if = $oc['if'];	
				}
			}
			
			if ($sa) {
				$ipfrules .= <<<EOD
pass in quick on {$if} from {$sa}/{$sn} to {$route['network']}
pass in quick on {$if} from {$route['network']} to {$sa}/{$sn}
pass out quick on {$if} from {$sa}/{$sn} to {$route['network']}
pass out quick on {$if} from {$route['network']} to {$sa}/{$sn}

EOD;
			}
		}
}
	foreach ($optcfg as $oc) {
		if($config['interfaces']['opt2']['wireless']['ifmode'] != 'lanbridge' && $config['interfaces']['opt2']['wirelless']['ifmode'] != 'dmzbridge')
	               	$ipfrules .= "block in $log quick on $wanif from {$oc['sa']}/{$oc['sn']} to any\n";
	}
	
	/* allow PPTP traffic if PPTP client is enabled on WAN */
	if ($wancfg['ipaddr'] == "pptp") {
		$ipfrules .= <<<EOD

#########################
### Allow PPTP client ###
#########################
pass in quick on {$wancfg['if']} proto gre from any to any
pass out quick on {$wancfg['if']} proto gre from any to any
pass in quick on {$wancfg['if']} proto tcp from any port 1723 to any
pass out quick on {$wancfg['if']} proto tcp from any to any port 1723

EOD;
	}
	
	if ($wancfg['ipaddr'] == "dhcp") {
		$ipfrules .= <<<EOD

############################################
### Allow our DHCP client out to the WAN ###
############################################
pass out quick on $wanif proto udp from any port 68 to any port 67
block in $log quick on $wanif proto udp from any port 67 to $lansa/$lansn port 68
pass in quick on $wanif proto udp from any port 67 to any port 68

EOD;
	}

$ipfrules .= <<<EOD

########################### 
### LAN/OPT spoof check ###
###########################
anchor "spoofed-source" {\n
EOD;
	/* LAN spoof check */
	/* omit if any interface is bridged to LAN and the filtering bridge is on */
	$lanbridge = false;
	for ($i = 1; isset($config['interfaces']['opt' . $i]); $i++) {
                if($config['interfaces']['opt' . $i]['wireless']['ifmode'] == 'lanbridge')
                $lanbridge = true;
        }
	if (!$lanbridge)
		$ipfrules .= "\t" . filter_rules_spoofcheck_generate('lan', $lanif, $lansa, $lansn, $log);

	/* OPT spoof check */
	/* omit for bridged interfaces when the filtering bridge is on */
	$isbridged = false;
	for ($i = 1; isset($config['interfaces']['opt' . $i]); $i++) {
                if($config['interfaces']['opt' . $i]['wireless']['ifmode'] == 'lanbridge' || $config['interfaces']['opt' . $i]['wireless']['ifmode'] == 'dmzbridge')
                $isbridged = true;
        }
        if (!$isbridged && isset($config['interfaces']['opt' . $i]['enable']))
		$ipfrules .= filter_rules_spoofcheck_generate($on, $oc['if'], $oc['sa'], $oc['sn'], $log);

	$ipfrules .= "}\n";

	/* block private networks on WAN? */
	if (isset($config['interfaces']['wan']['blockpriv'])) {
		$ipfrules .= <<<EOD

#############################################################
### Block anything from private networks on WAN interface ###
#############################################################
EOD;
$ipfrules .= "\nanchor \"Block RFC1918\" {\n\tblock in $log quick on $wanif from" . ' $RFC_1918 ' . "to any\n}\n";
	}
	
	/* IPsec enabled? */
	if (isset($config['ipsec']['enable']) && is_array($config['ipsec']['tunnel']) || isset($config['ipsec']['mobileclients']['enable']) && is_array($config['ipsec']['tunnel'])) {
		foreach( $config['ipsec']['tunnel'] as $tunnel ) {
			$ifname = $tunnel['interface'];
			if($ifname == 'wan') 
				$localip = get_current_wan_address();
			$ifname = get_interface_name($ifname);
			$remoteip = $tunnel['remote-gateway'];
			$tunnelmode = $tunnel['p2']['protocol'];
			$tunnelroutes = $tunnel['addresspolicies'];
			$ipfrules .= filter_rules_ipsec_generate($ifname, $localip, $remoteip, $tunnelmode, $tunnelroutes);
		}
	}
	
	/* If multiwan is enabled do this */
	if (isset($config['system']['multiwan'])) {
		$wanifs = filter_generate_multiwan_interfaces();
        	foreach($wanifs as $if) {
			$ipfrules .= "pass out on $if all\n";
			$otherwanifs = array();
			foreach($wanifs as $otherwan) {
				if($otherwan != $if) {
					array_push($otherwanifs, $otherwan); 
				}
			}
			foreach($otherwanifs as $otherif) {
				$gw = get_interface_gw($otherif);
				$ipfrules .= "pass out on $if route-to ($otherif $gw) from $otherif to any\n";
			}
		}
	}

        /* Webgui antilockout code */
	if (!isset($config['system']['general']['webgui']['noantilockout'])) {
		$webuiport = $config['system']['general']['webgui']['port'];
		if (!$webuiport) {
			$webuiport = '443';
		} else {
			$webuiport = $config['system']['general']['webgui']['port'];
		}
		if(isset($config['system']['general']['sshd']['enabled'])) {	
			$sshdport = ', 22';
		}

		$webuiport .= $sshdport;
	$ipfrules .= <<<EOD
	
###########################
### WebGUI anti-lockout ###
###########################
pass in quick on $lanif proto tcp from $lansa/$lansn to $lanip \
port { $webuiport }  

EOD;
	}
/* CARP code */
        if (isset($config['carp']['carpenable'])) {
        $ipfrules .= <<<EOD
                            
###########################
### Allow CARP Protocol ###
###########################
EOD;
       		if (is_array($config['carp']['virtualhost'])) { 
			foreach($config['carp']['virtualhost'] as $virtual) {
				$carpdev = $config['interfaces'][$virtual['interface']]['if'];
				$ipfrules .= "\npass in quick on $carpdev proto carp";
			}
		}
		$ipfrules .= "\n";
	}

/* PFSync code */
        if (isset($config['pfsync']['pfsyncenable'])) {
        $ipfrules .= <<<EOD

#############################
### Allow Sync Protocols ###
#############################
EOD;
                $syncdev = $config['interfaces'][$config['pfsync']['interface']]['if'];
		$syncip = $config['interfaces'][$config['pfsync']['interface']]['ipaddr'];
                $ipfrules .= "\npass in quick on $syncdev proto pfsync from any to 224.0.0.240";
		$ipfrules .= "\npass in quick on $syncdev proto tcp from any to $syncip port www";
		$ipfrules .= "\npass in quick on $syncdev proto udp from any to $syncip port dhcpd-sync";
	        $ipfrules .= "\npass in quick on $syncdev proto igmp from any to 224.0.1.240\n";	
        }

	/* PPTPd enabled? */
	if ($pptpdcfg['mode'] && ($pptpdcfg['mode'] != "off")) {
	
		if ($pptpdcfg['mode'] == "server") {
			$pptpdtarget = $curwanip;
		} else {
			$pptpdtarget = $pptpdcfg['redir'];
		}
		if ($pptpdtarget) {
			$ipfrules .= <<<EOD

##################
### PPTP rules ###
##################
pass in quick proto gre from any to $pptpdtarget 
pass in quick proto tcp from any to $pptpdtarget port 1723 
EOD;
		}
	}
	
	/* BigPond client enabled? */
	if ($wancfg['ipaddr'] == "bigpond") {
		
		$ipfrules .= <<<EOD

###############################
### BigPond heartbeat rules ###
###############################
pass in quick proto udp from any to any port 5050 

EOD;
	}

	$i = 0;
$ipfrules .= <<<EOD

##############################
##############################
##### User Defined Rules #####
##############################
##############################
\n\n
EOD;

	if (isset($config['filter']['rule']))
		foreach ($config['filter']['rule'] as $rule) {
		
		/* does the rule deal with a PPTP interface? */
		if ($rule['interface'] == "pptp") {
		
			if ($pptpdcfg['mode'] != "server") {
				$i++;
				continue;
			}
				
			$nif = $g['n_pptp_units'];
			$ispptp = true;
		} else {
			
			if (strstr($rule['interface'], "opt")) {
				if (!array_key_exists($rule['interface'], $optcfg)) {
					$i++;
					continue;
				}
			}
			
			$nif = 1;
			$ispptp = false;
		}
		
		if ($pptpdcfg['mode'] != "server") {
			if (($rule['source']['network'] == "pptp") ||
				($rule['destination']['network'] == "pptp")) {
					$i++;
					continue;
				}
		}
		
		if ($rule['source']['network'] && strstr($rule['source']['network'], "opt")) {
			if (!array_key_exists($rule['source']['network'], $optcfg)) {
				$i++;
				continue;
			}
		}
		if ($rule['destination']['network'] && strstr($rule['destination']['network'], "opt")) {
			if (!array_key_exists($rule['destination']['network'], $optcfg)) {
				$i++;
				continue;
			}
		}
		
		/* check for unresolvable aliases */
		if ($rule['source']['address'] && !alias_expand($rule['source']['address'])) {
			$i++;
			continue;
		}
		if ($rule['destination']['address'] && !alias_expand($rule['destination']['address'])) {
			$i++;
			continue;
		}
		
		for ($iif = 0; $iif < $nif; $iif++) {
			
			if (!$ispptp) {
			
				$interface = get_interface_name($rule['interface']);
				
				if (!$interface) {
					printf("Invalid interface name in rule $i\n");
					break;
				}
			}
	
			$protocols = array();
			/* determine if rule is to be redirected to a relay */
                        $relayrewrite = 'no';
                        if(isset($rule['portforward'])) {
                                $relayrewrite =  'yes';
	                }
                        if (isset($rule['dstlist'])) {
                                $dstlist = $rule['dstlist'];
                                for($i=0;$i<sizeof($dstlist); $i++) {
                                        $dst = "dst" . "$i";
                                        if(preg_match('/^relay:/', $dstlist[$dst])) {
                                                $relayrewrite = 'yes';
                                        	array_push($protocols, "tcp");
					}
                                }
                        }
			if ($rule['tcplist']) { 
				array_push($protocols, "tcp");
			}
			if ($rule['udplist']) {       
                                array_push($protocols, "udp");
                        }
			if ($rule['ipprotos']) {       
                                array_push($protocols, "ip");
                        }
			if (!$rule['tcplist'] && !$rule['udplist'] && !$rule['ipprotos'] && $relayrewrite == 'no') {
				array_push($protocols, "none");
			}
	
			$line .= filter_pad_comments($rule['name']) . "\n";
			$line .= "### " .  $rule['name'] . " ###\n";
			$line .= filter_pad_comments($rule['name']) . "\n";
			$line .= "anchor \"" . $rule['name'] . "\" {\n";
			foreach($protocols as $proto) { 		
	
			$type = $rule['type'];
			if ($type != "pass" && $type != "block" && $type != "reject") {
				/* default (for older rules) is pass */
				$type = "pass";
			}

			if ($type == "reject") {
				/* special reject packet */
				if ($proto == "tcp") {
					$line .= "\tblock return-rst";
				} else if ($proto == "udp") {
					$line .= "\tblock return-icmp(port-unr)";
				} else {
					$line .= "\tblock";
				}
			} else {
				$line .= "\t$type";
			}
			
			$line .= " in ";

			if (isset($rule['log']))
				$line .= "log ";

			$line .= "quick ";
			
			if ($ispptp) {
				$line .= "on ng" . ($iif+1) . " ";
			}

			if (!$ispptp) {
				$line .= "on $interface ";
			}

			$line .= "inet ";
	
			### Load Balancing code goes here. 	
			if (isset($config['system']['multiwan'])) {
				$line .= "route-to \\\n\t{ ";
				foreach($wanifs as $if) {
					$gw = get_interface_gw($if);
					$line .= "($if $gw), ";
				}
				$line = preg_replace("/\, $/", "", $line);
				$line .= " } round-robin \\\n\t";	
			}
			if($proto != 'none') {
				$line .= "proto $proto \\\n\t";
			}	
			/* source address */
			if (isset($rule['srclist'])) {
				$line .= "from { ";
				$srclist = $rule['srclist'];
				for($i=0;$i<sizeof($srclist); $i++) {
					$src = "src" . "$i";
                                        $srclist[$src] = preg_replace("/^user:/", "<", $srclist[$src]);	
				        $srclist[$src] = preg_replace("/:user$/", ">", $srclist[$src]);
					$line .= "$srclist[$src], ";
				}
				$line = preg_replace("/\, $/", "", $line);
				$line = preg_replace("/user:/", "<", $line);	
				$line = preg_replace("/:user/", ">", $line);
				$line.= " }";
			}
			
			/* rewrite dest of ftp connections to be 127.0.0.1 as they should be rdr'd previously*/
                	$ftprewrite = 'no';
			if($rule['tcplist']) {
                        	foreach($rule['tcplist'] as $tcpport) {
                                	if($tcpport == '21') {
                                		$ftprewrite =  'yes';
					}    
				}     
               		}
			
                        /* dest address */
                        if ($ftprewrite == 'yes') {
				$line .= " to { 127.0.0.1 } ";
			} elseif ($relayrewrite == 'yes') {
				$line .= " to { ";
				foreach($config['relays']['relay'] as $relay) {
					if ($relay['name'] == $rule['dstrelay']) {
                                       		if ($relay['forward'] == 'nat lookup') {
							$line .= $relay['listenerip'];
						}
					} else {
						$dstlist = $rule['dstlist'];
                                        		for($i=0;$i<sizeof($dstlist); $i++) {
                                                		$dst = "dst" . "$i";
								if (preg_match('/^relay:/', $dstlist[$dst])) { 
								$dstlist[$dst] = preg_replace('/^relay:/', '', $dstlist[$dst]);
								if ($relay['name'] == $dstlist[$dst]) {
									if ($relay['forward'] == 'serverpool') {
										$line .= $relay['listenerip'];
									}
								}
							}
						}
					}
				}
				$line .= " }";
			} else {
				if (isset($rule['dstlist'])) {
                        	        $line .= " to { ";
                                	$dstlist = $rule['dstlist'];
                               	 	for($i=0;$i<sizeof($dstlist); $i++) {
                                       	 	$dst = "dst" . "$i";
                                        	if(preg_match('/^\d+.\d+.\d+.\d+:/', $dstlist[$dst])) 
							$line .= preg_replace('/^\d+.\d+.\d+.\d+:/', '', $dstlist[$dst]) . ', '; 
						else 
							$line .= "$dstlist[$dst], ";
					}
                                	$line = preg_replace("/\, $/", "", $line);
                                	$line.= " } ";
                        	}
			}
		
			/*protocol ports stuff*/
				if ($ftprewrite == 'yes') {
					$line .= "\\\n\tport { 8021 }";
				} elseif ($relayrewrite == 'yes') {
                                	$line .= " \\\n\tport { ";
                                	foreach($config['relays']['relay'] as $relay) {
						if ($relay['name'] == $rule['dstrelay']) {
                                                	if ($relay['forward'] == 'nat lookup') {
                                                		$line .= $relay['listenerport'];
                                                	}
						}    
                                		$dstlist = $rule['dstlist'];
                                                for($i=0;$i<sizeof($dstlist); $i++) {
                                                $dst = "dst" . "$i";
                                                	if (preg_match('/^relay:/', $dstlist[$dst])) { 
                                                		$dstlist[$dst] = preg_replace('/^relay:/', '', $dstlist[$dst]);
                                                		if ($relay['name'] == $dstlist[$dst]) {
                                                			if ($relay['forward'] == 'serverpool') {
                                                				$line .= $relay['listenerport'];
                                                			}	    
                                                		}    
                                                	}    
                                                }
					}
                                	$line .= " }";	
				} else {
					if ($proto == "tcp" || $proto == "udp") {
                                		$portlist = $rule[$proto . "list"];
                                		$string = '';
                                		for($i=0;$i<sizeof($portlist); $i++) {
                                        		$protocol = "$proto" . "$i";
                                        		$string .= "$portlist[$protocol], ";
                                		}
                                		$string = preg_replace("/\, $/", "", $string);
						$line .= "\\\n\tport { $string }";	
					}
				}	
			
			if ($type == "pass") {
			
				if (isset($rule['options']['state'])) {
					if($rule['options']['state'] != 'none') {
						$line .= " {$rule['options']['state']}";
					}
				}
				$line = preg_replace("/,$/", '', $line);
				$optionsline = " \\\n\t(";
				if (isset($rule['options']['maxstates'])) {
					$optionsline .= "max {$rule['options']['maxstates']}, ";
				}
				if (isset($rule['options']['srctrack'])) {
					if($rule['options']['srctrack'] != 'none') {
						$optionsline .= "source-track {$rule['options']['srctrack']}, ";
					}
				}
				if (isset($rule['options']['maxsrcnodes'])) {
					$optionsline .= "max-src-nodes {$rule['options']['maxsrcnodes']}, ";
				}
				if (isset($rule['options']['maxsrcstates'])) {
					$optionsline .= "max-src-states {$rule['options']['maxsrcstates']}, ";
				}
				if (isset($rule['options']['maxsrcconns'])) {
                                        $optionsline .= "max-src-conn {$rule['options']['maxsrcconns']}, ";
                                }	
				if (isset($rule['options']['maxsrcconnrate'])) {
					$optionsline .= "max-src-conn-rate {$rule['options']['maxsrcconnrate']}, ";
				}
			 	if (isset($rule['options']['overload'])) {
                                        $optionsline .= 'overload <abusive_hosts> ';
                                }
				if (isset($rule['options']['flush'])) {
                                        $optionsline .= "flush, ";
                                }	
			        if(!preg_match("/\($/", $optionsline)) {
					$optionsline = preg_replace("/, $/", ')', $optionsline);
					$optionsline = preg_replace("/ $/", ')', $optionsline);
					$line .= $optionsline;
				}	
				if(isset($config['altq']['enable'])) {
					if (isset($rule['options']['altqbucket'])) {
                                        	$line .= "\\\n\tqueue ( " .  "{$rule['options']['altqbucket']}";
						if (isset($rule['options']['altqlowdelay'])) {
							$line .= ", ackout";
						}
						$line .= " )";	
					}
				}
			}	
		
			$line .= "\n";
			}
			$line .= "}\n";	
		}
		$i++;
	}
        $ipfrules .= $line;	
	$ipfrules .= <<<EOD

##########################
##### System Anchors #####
##########################
anchor "ftp-proxy/*"\n
anchor "vpn/*"\n
EOD;
if(isset($config['relays']['pfanchor']))
	$ipfrules .= 'anchor "relayd/*"' . "\n";
	
	return $ipfrules;
}

function filter_rdrrules_generate() {
	global $config, $g;
	
	$wancfg = $config['interfaces']['wan'];
	$lancfg = $config['interfaces']['lan'];
	$pptpdcfg = $config['pptpd'];
	
	$lanif = $lancfg['if'];
	$wanif = get_real_wan_interface();
	
	$curwanip = get_current_wan_address();
	
	/* rule groups (optional interfaces: see below) */
	/*$ifgroups = array("lan" => 100, "wan" => 200);*/
	
	$lanip = $lancfg['ipaddr'];
	$lansa = gen_subnet($lancfg['ipaddr'], $lancfg['subnet']);
	$lansn = $lancfg['subnet'];
	
	/* optional interfaces */
	$optcfg = array();
	
	for ($i = 1; isset($config['interfaces']['opt' . $i]); $i++) {
		$oc = $config['interfaces']['opt' . $i];
		
		if (isset($oc['enable']) && $oc['if']) {
			$oic = array();
			$oic['if'] = $oc['if'];
			
			if ($oc['bridge']) {
				if (!strstr($oc['bridge'], "opt") || 
					 isset($config['interfaces'][$oc['bridge']]['enable'])) {
					if (is_ipaddr($config['interfaces'][$oc['bridge']]['ipaddr'])) {
						$oic['ip'] = $config['interfaces'][$oc['bridge']]['ipaddr'];
						$oic['sn'] = $config['interfaces'][$oc['bridge']]['subnet'];
						$oic['sa'] = gen_subnet($oic['ip'], $oic['sn']);
					}
				}
				$oic['bridge'] = 1;
				$oic['bridge_if'] = $oc['bridge'];
			} else {
				$oic['ip'] = $oc['ipaddr'];
				$oic['sn'] = $oc['subnet'];
				$oic['sa'] = gen_subnet($oic['ip'], $oic['sn']);
			}
			
			$optcfg['opt' . $i] = $oic;
			/*$ifgroups['opt' . $i] = ($i * 100) + 200;*/
		}
	}
	
	$ipfrules = "#################\n";
	$ipfrules .= "### RDR rules ###\n";
	$ipfrules .= "#################\n";

	/* if we have a rule with dst port 20/21 setup the ftpproxy anchor */
        $ipfrules .= 'rdr-anchor "ftp-proxy/*"' . "\n";
	$ipfrules .= 'rdr-anchor "relayd/*"' . "\n";
	$i = 0;
	if (isset($config['filter']['rule']))
		foreach ($config['filter']['rule'] as $rule) {
	
		/* does the rule deal with a PPTP interface? */
                if ($rule['interface'] == "pptp") {

	                if ($pptpdcfg['mode'] != "server") {
        	                 $i++;
                                 continue;
                        }

                        $nif = $g['n_pptp_units'];
                        $ispptp = true;
                } else {

                        if (strstr($rule['interface'], "opt")) {
	                        if (!array_key_exists($rule['interface'], $optcfg)) {
        	                        $i++;
                	                continue;
                                }
                        }

                        $nif = 1;
                        $ispptp = false;
                }
		/* check to see if there are rdr's in this rule */
		$rdrexists = 0;
		$rdrlist = array();
		/* configured snats */
		foreach($rule['dstlist'] as $dstlist) {
			if(preg_match('/^\d+.\d+.\d+.\d+:/', $dstlist)) {
				array_push($rdrlist, $dstlist);
				$rdrexists = 1;
			}
		}
		/* hijack ftp connections and send them to the proxy */
		if($rule['tcplist']) {
			foreach($rule['tcplist'] as $tcpport) {
				if($tcpport == '21') {
					array_push($rdrlist,'ftp:' . $rule[$dstlist]);
					$rdrexists = 1;
				}
			}	
		}	
		/* hijack connections user specifies to send to a relay */
                if(isset($rule['portforward'] )) {
			foreach($config['relays']['relay'] as $relay) { 
                       		if ($relay['name'] == $rule['dstrelay']) {
                			if($relay['forward'] != 'nat lookup') {
						continue 2;
					}
				}
			}	
			array_push($rdrlist,'relay:' . $rule['dstrelay'] . ':' . $rule[$dstlist]);
			$rdrexists = 1; 
                }
 
		if ($rdrexists == 0) {
			$i++;
			continue;
		}	
		/* put a comment of the name for the rdr rule(s) */
		$line .= "\n";
                $line .= filter_pad_comments($rule['name']) . "\n";
                $line .= "### " .  $rule['name'] . " ###\n";
                $line .= filter_pad_comments($rule['name']) . "\n";

		foreach($rdrlist as $rdr) {
			if (preg_match('/^\d+.\d+.\d+.\d+:\d+.\d+.\d+.\d+$/', $rdr)) {
				$external = preg_replace('/:\d+.\d+.\d+.\d+$/','', $rdr);
				if (preg_match('/^\d+.\d+.\d+.\d+:/', $rdr)) {
					$internal = preg_replace('/^\d+.\d+.\d+.\d+:/',"", $rdr);
				}
			}
			elseif (preg_match('/^ftp:/', $rdr)) {
				$external = preg_replace('/^ftp"/','', $rdr);
				$internal = '127.0.0.1 port 8021';
                        }    
			elseif (preg_match('/^relay:/', $rdr)) {
                                $relayname = preg_replace('/relay:/','', $rdr);
				$relayname = preg_replace('/:.?$/','', $relayname);
				$rdr = preg_replace('/^.?:/','', $rdr);
				foreach($config['relays']['relay'] as $relay) { 
					if ($relay['name'] == $relayname) {
						
						$external = preg_replace('/^relay:/','', $rdr); 
						$internal = $relay['listenerip'] . ' port ' . $relay['listenerport'];
					}
				}
			}
			if (($rule['source']['network'] == "pptp") || ($rule['destination']['network'] == "pptp")) {
				$i++;
				continue;
			}
			for ($iif = 0; $iif < $nif; $iif++) {
			
				if (!$ispptp) {
			
					$interface = get_interface_name($rule['interface']);
				
					if (!$interface) {
						printf("Invalid interface name in rule $i\n");
						break;
					}
				}
		
				$protocols = array();
				if ($rule['tcplist']) { 
					array_push($protocols, "tcp");
				}
				if ($rule['udplist']) {       
        	                        array_push($protocols, "udp");
               		        }
				if ($rule['ipprotos']) {       
	                                array_push($protocols, "ip");
		                }
				if (!$rule['tcplist'] && !$rule['udplist'] && !$rule['ipprotos']) {
					array_push($protocols, "none");
				}
	
				foreach($protocols as $proto) { 		
	
				$type = $rule['type'];
				if ($type != "pass" && $type != "block" && $type != "reject") {
				/* default (for older rules) is pass */
				}

				if ($ispptp) {
					$line .= "on ng" . ($iif+1) . " ";
				}

				if (!$ispptp) {
					$line .= "rdr on $interface ";
				}
			
				if($proto != 'none') {
					$line .= "proto $proto \\\n";
				}	
				/* source address */
				if (isset($rule['srclist'])) {
					$line .= "from { ";
					$srclist = $rule['srclist'];
					for($i=0;$i<sizeof($srclist); $i++) {
						$src = "src" . "$i";
						$line .= "$srclist[$src], ";
					}
					$line = preg_replace("/\, $/", "", $line);
					$line.= " }";
				}
				 /* dest address */
				if (isset($rule['dstlist'])) {
                                        $line .= " to { ";
                                        $dstlist = $rule['dstlist'];
                                        for($i=0;$i<sizeof($dstlist); $i++) {
                                                $dst = "dst" . "$i";
                                                if (preg_match('/:\d+.\d+.\d+.\d+$/', $dstlist[$dst])) {
                                			$dstlist[$dst] = preg_replace('/:\d+.\d+.\d+.\d+$/','', $dstlist[$dst]);
						}
						$line .= "$dstlist[$dst], ";
                                        }    
                                        $line = preg_replace("/\, $/", "", $line);
                                        $line.= " }";
                                }	
				/*protocol ports stuff*/
				if ($proto == "tcp" || $proto == "udp") {
					$portlist = $rule[$proto . "list"];
       		                         $string = '';
					for($i=0;$i<sizeof($portlist); $i++) {
                        	                $protocol = "$proto" . "$i";
                                	        $string .= "$portlist[$protocol], ";
                                	}
					$string = preg_replace("/\, $/", "", $string);
					$line .= "\\\nport{ $string } -> $internal";	
				}	
			
				$line .= "\n\n";
				}
			}	
		}	
		$i++;
	}
	$ipfrules .= $line;
	return $ipfrules;
}

function filter_rules_spoofcheck_generate($ifname, $if, $sa, $sn, $log) {

	global $g, $config;
	
	$ipfrules = "";

		$ipfrules .= "block in $log quick on $if from ! $sa/$sn to any\n";
	
	return $ipfrules;
}

function filter_rules_ipsec_generate($ifname, $localip, $remoteip, $tunnelmode, $tunnelroutes) {
	$ipfrules .= <<<EOD

#######################################
##### Gateway rules for $remoteip #####
#######################################
pass in quick on {$ifname} proto udp from {$remoteip} to {$localip} port {500, 4500}
EOD;
if($tunnelmode == 'esp') {
$ipfrules .= <<<EOD
\npass in quick on {$ifname} proto esp from {$localip} to {$remoteip}
EOD;
}
if($tunnelmode == 'ah') {
$ipfrules .= <<<EOD
\npass in quick on {$ifname} proto ah from {$localip} to {$remoteip}
EOD;
}
$ipfrules .= <<<EOD
\npass in quick on enc0 proto ipencap from {$localip} to {$remoteip} \
        keep state (if-bound)
EOD;
foreach($tunnelroutes as $route) { 
	preg_match('/(\d+.\d+.\d+.\d+)--(\d+.\d+.\d+.\d+)/', $route, $ips);
$local = $ips[1];
$remote = $ips[2];
$ipfrules .= <<<EOD
\npass in quick on enc0 from $local to $remote \
	keep state (if-bound)

EOD;
}
	return $ipfrules;
}

?>
