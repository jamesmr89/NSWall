<?php
/*
 $Id: filter.inc,v 1.137 2009/04/20 17:51:02 jrecords Exp $
 part of m0n0wall (http://m0n0.ch/wall)

 Copyright (C) 2003-2006 Manuel Kasper <mk@neon1.net>.
 All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice,
 this list of conditions and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright
 notice, this list of conditions and the following disclaimer in the
 documentation and/or other materials provided with the distribution.

 THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
 OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 POSSIBILITY OF SUCH DAMAGE.
 */

/* include all configuration functions */
require_once("functions.inc");

/* returns the ruleset number for the anchorname */
function filter_get_anchornumber($rule) {
	$pfrules = `/sbin/pfctl -vvs rules`;
	$pfrules = split("\n", $pfrules);
	foreach ($pfrules as $line) {
		$pattern = "/^\@(\d+)\sanchor\s\"$rule\"/";
		if (preg_match_all($pattern, $line, $matches)) {
			return($matches[1][0]);
		}
	}
}

function filter_pad_comments($string) {
	$length = strlen($string);
	for($i=0;$i<$length + 8;$i++) {
		$retval .= '#';
	}
	return $retval;
}

function filter_print_pfconf() {
	printf("########################################\n");
	printf("### pf.conf file generated by NSWall ###\n");
	printf("########################################\n\n");
	$natrules = filter_nat_rules_generate();
	$rdrrules = htmlentities(filter_rdrrules_generate());
	$pfrules = htmlentities(filter_rules_generate());
	$altqconf = altq_conf_generate();
	$aliasrules = filter_aliasrules_generate();
	$pfoptions = filter_options_generate();
	$pfnormalization = filter_normalization_generate();
	$tables = htmlentities(filter_tables_generate());
	printf("$tables");
	printf("$aliasrules");
	printf("$pfoptions\n");
	printf("$pfnormalization\n");
	printf("$altqconf\n");
	printf("$rdrrules\n");
	printf("$natrules\n");
	printf("$pfrules\n");
}

function filter_generate_multiwan_interfaces() {
	global $config, $g;
	system_determine_hwplatform();
	if (isset($config['system']['advanced']['multiwansupport']) && sg_get_const("ENTERPRISE_ROUTING") == 'ENABLED') {
		$wanifs = array();
		array_push($wanifs, get_real_wan_interface());
		for ($i = 1; isset($config['interfaces']['opt' . $i]); $i++) {
			$oc = $config['interfaces']['opt' . $i];
			if (isset($oc['enable'])) {
				if($oc['iftype'] == 'wan') {
					array_push($wanifs, $g['hwplatformconfig'][INTERFACES]['OPT' . $i]['IF']);
				}
			}
		}
	}
	return $wanifs;
}

function filter_configure() {
	global $config, $g;

	if ($g['booting'])
	echo "Configuring Firewall... ";

	/* generate pf rules */
	$pfrules = filter_tables_generate();
	$pfrules .= filter_aliasrules_generate();
	$pfrules .= filter_options_generate();
	$pfrules .= filter_normalization_generate();
	$pfrules .= altq_conf_generate();
	$pfrules .= filter_nat_rules_generate();
	$pfrules .= filter_rdrrules_generate();
	$pfrules .= filter_rules_generate();

	/* load pf ruleset */
	if(isset($config['system']['pfdebug'])) {
		$fd = popen("/sbin/pfctl -Fq -Fr -FT -vv -f - > /tmp/pfctl.error", "w");
		if (!$fd) {
			printf("Cannot open /sbin/pfctl in filter_configure()\n");
			return 1;
		}

		fwrite($fd, $pfrules);
		pclose($fd);

		$debug_pfconf = fopen("/tmp/pf.conf.debug", "w+") or die("Couldn't create new file");
		$pfconfdebug = preg_split('/\n/', $pfrules);
		$i = 1;
		foreach($pfconfdebug as $line) {
			fwrite($debug_pfconf, "$i\t$line" . "\n");
			$i++;
		}
		fclose($debug_pfconf);

	} else {
		$fd = popen("/sbin/pfctl -Fq -Fr -FT -q -f - > /dev/null 2>&1", "w");
		if (!$fd) {
			printf("Cannot open /sbin/pfctl in filter_configure()\n");
			return 1;
		}

		fwrite($fd, $pfrules);
		pclose($fd);
	}

	if ($g['booting'])
	echo "done\n";

	return 0;

}

function filter_parse_config($config) {
	global $config, $g;

	system_determine_hwplatform();

	/* generate pf rules */
	$pfrules = filter_tables_generate();
	$pfrules .= filter_aliasrules_generate();
	$pfrules .= filter_options_generate();
	$pfrules .= filter_normalization_generate();
	$pfrules .= altq_conf_generate();
	$pfrules .= filter_nat_rules_generate();
	$pfrules .= filter_rdrrules_generate();
	$pfrules .= filter_rules_generate();

	$descriptorspec = array(
	0 => array("pipe", "r"),  // stdin is a pipe that the child will read from
	1 => array("pipe", "w"),  // stdout is a pipe that the child will write to
	2 => array("pipe", "w") // stderr is a file to write to
	);

	/* load pf ruleset */
	$process = proc_open("/sbin/pfctl -gnf -", $descriptorspec, $pipes );
	if (is_resource($process)) {
		// $pipes now looks like this:
		// 0 => writeable handle connected to child stdin
		// 1 => readable handle connected to child stdout
		// Any error output will be appended to /tmp/error-output.txt

		fwrite($pipes[0], $pfrules);
		fclose($pipes[0]);
		while (!feof($pipes[2])) {
			$out .=  fgets($pipes[2], 128);
		}
		fclose($pipes[2]);
	}
	$return_value = proc_close($process);

	if($return_value) {
		$fh = fopen("/tmp/pf.conf.raw", 'w') or die("can't open file");
		fwrite($fh, $pfrules);
		fclose($fh);
		$errors = preg_split("/stdin:/", $out);
		foreach($errors as $error) {
			mwexec("/usr/bin/logger -p local0.info -t configparse $error");
		}
	}
	return $return_value;
}

function filter_enable_pf() {
	global $config, $g;

	if ($g['booting'])
	echo "Enabling PF... ";

	mwexec("/sbin/pfctl -e");

	if ($g['booting'])
	echo "done\n";
}

function filter_flush_nat_table() {
	global $config, $g;

	return mwexec("/sbin/pfctl -F nat");
}

function filter_flush_state_table() {
	global $config, $g;

	return mwexec("/sbin/pfctl -F states");
}

function filter_nat_rules_generate_if($if, $src, $dst, $target, $portmap = true) {
	if (is_ipaddr($target)) {
		$natrule .= "match out on $if from $src $dst nat-to $target\n";
	} else {
		$natrule .= "match out on $if from $src $dst nat-to ($if)\n";
	}
	return $natrule;
}

function filter_tables_generate() {
	global $config, $g;

	$line = <<<EOD

################
#### Tables  ###
################

EOD;

	$line .= filter_static_blocked_sites_generate();

	if (isset($config['filter']['rule'])) {
		foreach ($config['filter']['rule'] as $rule) {
			if($rule['srclist']['src0'] != 'any') {
				/* source address */
				if (isset($rule['srclist'])) {
					$line .= "\ntable <" . $rule['name'] . "_src> { ";
					$srclist = $rule['srclist'];
					for($i=0;$i<sizeof($srclist); $i++) {
						$src = "src" . "$i";
						$line .= "$srclist[$src], ";
					}
					$line = preg_replace("/\, $/", "", $line);
					$line .= " } persist counters";
				}
			}
			/* destination address */
			if($rule['dstlist']['dst0'] != 'any') {
				 
				 
				if (isset($rule['dstlist'])) {
					unset($rdrset);
					$line .= "\ntable <" . $rule['name'] . "_dst> { ";
					$dstlist = $rule['dstlist'];
					for($i=0;$i<sizeof($dstlist); $i++) {
						$dst = "dst" . "$i";
						if (preg_match('/^\d+.\d+.\d+.\d+:/', $dstlist[$dst])) {
							$dstlist[$dst] = preg_replace('/^\d+.\d+.\d+.\d+:/','', $dstlist[$dst]);
							$rdrset = true;
						} elseif (preg_match('/^WAN_IF:/', $dstlist[$dst])) {
							$dstlist[$dst] = preg_replace('/^WAN_IF:/','', $dstlist[$dst]);
							$rdrdhcp = true;
						}
						$line .= "$dstlist[$dst], ";
					}
					$line = preg_replace("/\, $/", "", $line);
					$line .= " } persist counters";
					if ($rdrset && !$rdrdhcp) {
						$line .= "\ntable <" . $rule['name'] . "_dst_ext> { ";
						$dstlist = $rule['dstlist'];
						for($i=0;$i<sizeof($dstlist); $i++) {
							$dst = "dst" . "$i";
							if (preg_match('/^\d+.\d+.\d+.\d+:/', $dstlist[$dst])) {
								$dstlist[$dst] = preg_replace('/:\d+.\d+.\d+.\d+$/','', $dstlist[$dst]);
								$line .= "$dstlist[$dst], ";
							}
						}
						$line = preg_replace("/\, $/", "", $line);
						$line .= " } persist counters";
					}
				}
			}
		}
	}


	$line .= <<<EOD


#############
### Users ###
#############


EOD;
	if (is_array($config['system']['accounts']['user'])) {
		foreach ($config['system']['accounts']['user'] as $user) {
			$line .= 'table <' . $user['name'] . '> persist counters' . "\n";
		}
	}

	$line .= <<<EOD

##############
### Groups ###
##############

EOD;

	if (is_array($config['system']['accounts']['group'])) {
		foreach ($config['system']['accounts']['group'] as $group) {
			$line .= 'table <' . $group['name'] . '> persist counters' . "\n";
		}
	}

	$line .= "\n";

	return $line;
}

function filter_static_blocked_sites_generate() {
	global $config, $g;
	$line = '';
	if (isset($config['filter']['blockedsites'])) {

		unset($recursive);
		if (isset($config['filter']['blockedsites']['memberlist'])) {
			$memberlist = $config['filter']['blockedsites']['memberlist'];
			for($i=0;$i<sizeof($memberlist); $i++) {
				$mem = "member" . "$i";
			}
			$line .= 'table <static_abusive_sites>' .  ' { ';
			 
			for($i=0;$i<sizeof($memberlist); $i++) {
				$mem = "member" . "$i";
				$line .= "$memberlist[$mem], ";
			}
			$line = preg_replace('/, $/', '', $line);
		}
		$line .= ' } persist counters' . "\n";
		unset($recursive);
		/*if (isset($config['filter']['blockedsites']['nonmemberlist'])) {
		 $nonmemberlist = $config['filter']['blockedsites']['nonmemberlist'];
		 for($i=0;$i<sizeof($nonmemberlist); $i++) {
		 $mem = "nonmember" . "$i";
		 }
		 $line .= 'table <dynamic_blocked_sites>' .  ' { ';
		  
		 for($i=0;$i<sizeof($nonmemberlist); $i++) {
		 $mem = "nonmember" . "$i";
		 $line .= "!$nonmemberlist[$mem], ";
		 }
		 $line = preg_replace('/, $/', '', $line);
		 }
		 $line .= ' } persist counters' . "\n";
		 */
	}
	return $line;
}

function filter_aliasrules_generate() {
	global $config, $g;
	$line = "###############\n";
	$line .= "### Aliases ###\n";
	$line .= "###############\n";
	$line .= filter_system_aliases_generate();
	if (isset($config['aliases']['alias'])) {
		foreach ($config['aliases']['alias'] as $alias) {
			unset($recursive);
			if (isset($alias['memberlist'])) {
				$memberlist = $alias['memberlist'];
				for($i=0;$i<sizeof($memberlist); $i++) {
					$mem = "member" . "$i";
					if(preg_match('/^\$/', $memberlist[$mem]))
					$recursive = 'TRUE';
				}
				$line .= $alias['name'] . ' =' .  " \"";
				if(sizeof($memberlist) != '1')
				$line .= "{";
				if($recursive == 'TRUE')
				$line .= '" ';
				for($i=0;$i<sizeof($memberlist); $i++) {
					$mem = "member" . "$i";
					$line .= "$memberlist[$mem] ";
				}
				$line = preg_replace('/ $/', '', $line);
				if($recursive == 'TRUE')
				$line .= ' "';
				if(sizeof($memberlist) != '1')
				$line .= "}";
			}
			$line .= '"';
			$line .= "\n";
		}
	}
	$line .= "\n";
	return $line;
}

function filter_expand_alias($name) {
	global $config, $g;
	if (isset($config['aliases']['alias'])) {
		foreach ($config['aliases']['alias'] as $alias) {
			if($alias['name'] == $name) {
				if (isset($alias['memberlist'])) {
					$memberlist = $alias['memberlist'];
					for($i=0;$i<sizeof($memberlist); $i++) {
						$mem = "member" . "$i";
						$string .= "$memberlist[$mem] ";
					}
					$string = preg_replace('/ $/', '', $string);
				}
			}
		}
	}
	return $string;
}

function filter_nat_rules_generate() {
	global $config, $g;

	system_determine_hwplatform();

	$wancfg = $config['interfaces']['wan'];
	$lancfg = $config['interfaces']['lan'];
	$lancfg['if'] = $g['hwplatformconfig'][INTERFACES][LAN];
	$wancfg['if'] = $g['hwplatformconfig'][INTERFACES][WAN];
	$pptpdcfg = $config['pptpd'];

	$lanif = $lancfg['if'];
	$wanif = get_real_wan_interface();
	$curwanip = get_current_wan_address();

	$lansa = gen_subnet($lancfg['ipaddr'], $lancfg['subnet']);

	$natrules = "\n#################\n";
	$natrules .= "### NAT rules ###\n";
	$natrules .= "#################\n";

	/* any 1:1 mappings? */
	if (is_array($config['nat']['onetoone'])) {
		foreach ($config['nat']['onetoone'] as $natent) {
			if (!is_numeric($natent['subnet']))
			$sn = 32;
			else
			$sn = $natent['subnet'];

			if (!$natent['interface'] || ($natent['interface'] == "wan"))
			$natif = $wanif;
			else
			$natif = $config['interfaces'][$natent['interface']]['if'];

			$natrules .= "binat on {$natif} from {$natent['internal']} to any -> {$natent['external']}\n";
		}
	}

	/* Dynamic outbound rules - advanced or standard */
	if (is_array($config['nat']['advancedoutbound']['rule'])) {
		foreach ($config['nat']['advancedoutbound']['rule'] as $obent) {
			$dst = "to any";
			$src = "";
			if (!isset($obent['destination']['any'])) {
				if (isset($obent['destination']['not']))
				$dst = "! to ";
				else
				$dst = "to ";
				$dst .= $obent['destination']['network'];
			}
			$src .= $obent['source']['network'];

			if (!$obent['interface'] || ($obent['interface'] == "wan"))
			$natif = $wanif;
			elseif ($obent['interface'] == "pptp")
			$natif = 'tun0';
			else
			$natif = get_interface_name_by_descr($obent['interface']);

			$natrules .= filter_nat_rules_generate_if($natif, $src, $dst,
			$obent['target'], !isset($obent['noportmap']));
		}
	}

	if (isset($config['pptp']['client']['autonat']))
	$natrules .= "nat on tun0 from any to any -> (tun0)\n";

	/* DIAG: add ipv6 NAT, if requested */
	if (isset($config['diag']['ipv6nat']['enable'])) {
		$natrules .= "rdr $wanif 0/0 port 0 -> " .
        "{$config['diag']['ipv6nat']['ipaddr']} port 0 ipv6\n";
	}

	if (isset($config['nat']['rule'])) {
		foreach ($config['nat']['rule'] as $rule) {

			$extport = explode("-", $rule['external-port']);
			$target = alias_expand_host($rule['target']);

			if (!$target)
			continue;   /* unresolvable alias */

			if ($rule['external-address'])
			$extaddr = $rule['external-address'] . "/32";
			else
			$extaddr = "0/0";

			if (!$rule['interface'] || ($rule['interface'] == "wan"))
			$natif = $wanif;
			else
			$natif = $config['interfaces'][$rule['interface']]['if'];

			if ((!$extport[1]) || ($extport[0] == $extport[1])) {
				$natrules .=
                    "rdr $natif {$extaddr} port {$extport[0]} -> {$target} " .
                    "port {$rule['local-port']} {$rule['protocol']}";
			} else {
				$natrules .=
                    "rdr $natif {$extaddr} port {$extport[0]}-{$extport[1]} " .
                    "-> {$target} " .
                    "port {$rule['local-port']} {$rule['protocol']}";
			}

			$natrules .= "\n";
		}
	}

	if ($pptpdcfg['mode'] == "redir" && $pptpdcfg['redir']) {

		$natrules .= <<<EOD

# PPTP
rdr $wanif 0/0 port 0 -> {$pptpdcfg['redir']} port 0 gre
rdr $wanif 0/0 port 1723 -> {$pptpdcfg['redir']} port 1723 tcp

EOD;
	}

	return $natrules;
}

function altq_conf_generate() {
	global $config, $g;
	$usingaltq = 0;
	$altqconf = "#####################\n";
	$altqconf .= "### ALTQ settings ###\n";
	$altqconf .= "#####################\n";
	foreach ($config['interfaces'] as $if) {
		if (isset($if['altqenable'])) {
			$usingaltq = 1;
			if (isset($if['descr'])) {
				$ifname = get_interface_name_by_descr($if['descr']);
			} else {
				$ifname = get_interface_name_by_descr('wan');
			}
			$bandwidth = $if['bandwidth'] . "Kb";
			$altqconf .= "altq on $ifname priq bandwidth $bandwidth queue { ackout, highest, high, medium, low }\n";
		}
	}
	if ($usingaltq == 1) {
		$altqconf .= "queue ackout   priority 4\n";
		$altqconf .= "queue highest  priority 3\n";
		$altqconf .= "queue high     priority 2\n";
		$altqconf .= "queue medium   priq(default)\n";
		$altqconf .= "queue low      priority 0\n";
	}
	return $altqconf;
}

function filter_options_generate() {
	global $config, $g;
	$pfglobals = "#########################\n";
	$pfglobals .= "### Global PF Options ###\n";
	$pfglobals .= "#########################\n";
	$pfglobals .= "set skip on lo0\n";

	system_determine_hwplatform();

	$hwplatformconfig = parse_nonconfig_xml("{$g['etc_path']}/hwplatformconfig.xml");
	 
	#$pfglobals .= 'set loginterface '.$g['hwplatformconfig'][INTERFACES][LAN]."\n";
	$pfglobals .= 'set loginterface '.$g['hwplatformconfig'][INTERFACES][WAN]."\n";;

	/* $ifcount = sizeof($g['hwplatformconfig'][INTERFACES]) - 2;

	for ($i = 1; $i<=$ifcount; $i++) {
	$pfglobals .= 'set loginterface '.$g['hwplatformconfig'][INTERFACES]['OPT' . $i]['IF']."\n";
	}
	*/

	if (isset($config['filter']['options']['timeouts']['tcpfirst']))
	$pfglobals .= "set timeout tcp.first " . $config['filter']['options']['timeouts']['tcpfirst'] . "\n";
	if (isset($config['filter']['options']['timeouts']['tcpopening']))
	$pfglobals .= "set timeout tcp.opening " . $config['filter']['options']['timeouts']['tcpopening'] . "\n";
	if (isset($config['filter']['options']['timeouts']['tcpestablished']))
	$pfglobals .= "set timeout tcp.established " . $config['filter']['options']['timeouts']['tcpestablished'] . "\n";
	if (isset($config['filter']['options']['timeouts']['tcpclosing']))
	$pfglobals .= "set timeout tcp.closing " . $config['filter']['options']['timeouts']['tcpclosing'] . "\n";
	if (isset($config['filter']['options']['timeouts']['tcpfinwait']))
	$pfglobals .= "set timeout tcp.finwait " . $config['filter']['options']['timeouts']['tcpfinwait'] . "\n";
	if (isset($config['filter']['options']['timeouts']['tcpclosed']))
	$pfglobals .= "set timeout tcp.closed " . $config['filter']['options']['timeouts']['tcpclosed'] . "\n";
	if (isset($config['filter']['options']['timeouts']['udpfirst']))
	$pfglobals .= "set timeout udp.first " . $config['filter']['options']['timeouts']['udpfirst'] . "\n";
	if (isset($config['filter']['options']['timeouts']['udpsingle']))
	$pfglobals .= "set timeout udp.single " . $config['filter']['options']['timeouts']['udpsingle'] . "\n";
	if (isset($config['filter']['options']['timeouts']['udpmultiple']))
	$pfglobals .= "set timeout icmp.first " . $config['filter']['options']['timeouts']['icmpfirst'] . "\n";
	if (isset($config['filter']['options']['timeouts']['icmperror']))
	$pfglobals .= "set timeout icmp.error " . $config['filter']['options']['timeouts']['icmperror'] . "\n";
	if (isset($config['filter']['options']['timeouts']['otherfirst']))
	$pfglobals .= "set timeout other.first " . $config['filter']['options']['timeouts']['otherfirst'] . "\n";
	if (isset($config['filter']['options']['timeouts']['othersingle']))
	$pfglobals .= "set timeout other.single " . $config['filter']['options']['timeouts']['othersingle'] . "\n";
	if (isset($config['filter']['options']['timeouts']['othermultiple']))
	$pfglobals .= "set timeout other.multiple " . $config['filter']['options']['timeouts']['othermultiple'] . "\n";
	if (isset($config['filter']['options']['timeouts']['adaptivestart']))
	$pfglobals .= "set timeout adaptive.start " . $config['filter']['options']['timeouts']['adaptivestart'] . "\n";
	if (isset($config['filter']['options']['timeouts']['adaptivestop']))
	$pfglobals .= "set timeout adaptive.end " . $config['filter']['options']['timeouts']['adaptivestop'] . "\n";
	if (isset($config['filter']['options']['limits']['maxstates']))
	$pfglobals .= "set limit states " . $config['filter']['options']['limits']['maxstates'] . "\n";
	if (isset($config['filter']['options']['limits']['maxfrags']))
	$pfglobals .= "set limit frags " . $config['filter']['options']['limits']['maxfrags'] . "\n";
	if (isset($config['filter']['options']['limits']['srcnodes']))
	$pfglobals .= "set limit src-nodes " . $config['filter']['options']['limits']['srcnodes'] . "\n";
	if (isset($config['filter']['options']['opt']['rulesetopt']))
	$pfglobals .= "set ruleset-optimization " . $config['filter']['options']['opt']['rulesetopt'] . "\n";
	if (isset($config['filter']['options']['opt']['stateopt']))
	$pfglobals .= "set optimization " . $config['filter']['options']['opt']['stateopt'] . "\n";
	if (isset($config['filter']['options']['opt']['blockpol']))
	$pfglobals .= "set block-policy " . $config['filter']['options']['opt']['blockpol'] . "\n";
	if (isset($config['filter']['options']['opt']['statepol']))
	$pfglobals .= "set state-policy " . $config['filter']['options']['opt']['statepol'] . "\n";
	#$pfglobals .= "set skip on lo0\n";

	return $pfglobals;
}

function filter_normalization_generate() {
	global $config, $g;
	$ipfrules = <<<EOD
#############################
### Traffic Normalization ###
#############################

EOD;

	if (isset($config['filter']['options']['scrub']['dfbit']))
	$normalrule .= "no-df ";
	if (isset($config['filter']['options']['scrub']['minttl']))
	$normalrule .= "min-ttl " . $config['filter']['options']['scrub']['minttl'] . " ";
	if (isset($config['filter']['options']['scrub']['maxmss']))
	$normalrule .= "max-mss " . $config['filter']['options']['scrub']['maxmss'] . " ";
	if (isset($config['filter']['options']['scrub']['randid']))
	$normalrule .= "random-id ";
	if (isset($config['filter']['options']['scrub']['reassembletcp']))
	$normalrule .= "reassemble tcp";
	if ($normalrule)
	$ipfrules .= "\nmatch in all scrub ( " . $normalrule . ")\n";

	return $ipfrules;
}

function filter_system_aliases_generate() {
	global $config, $g;

	$lancfg = $config['interfaces']['lan'];

	$sysalias_rules = 'RFC_1918 = "{ 192.168.0.0/16, 172.16.0.0/12, 10.0.0.0/8 }"' . "\n";
	$lansn = gen_subnet($lancfg['ipaddr'],$lancfg['subnet']);
	$sysalias_rules .= 'LAN_IP = "' . $lancfg['ipaddr'] . "\"\n";
	$sysalias_rules .= 'LAN_Network = "' . $lansn .  '/' . $lancfg['subnet'] . "\"\n";


	for ($i = 1; isset($config['interfaces']['opt' . $i]); $i++) {
		$oc = $config['interfaces']['opt' . $i];
		if (isset($oc['enable'])) {
			if($oc['wireless']['ifmode'] == 'lanbridge' || $oc['wireless']['ifmode'] == 'dmzbridge') {
				continue;
			}
			if ($oc['ipaddr'] == 'dhcp') {
				$interface = get_interface_name_by_descr($oc['descr']);
				if (file_exists("/tmp/$interface.ip"))
				$ip = chop(file_get_contents("/tmp/$interface.ip"));
				if (file_exists("/tmp/$interface.subnet"))
				$sn = mask2cidr(chop(file_get_contents("/tmp/$interface.subnet")));
				if (file_exists("/tmp/$interface.gw"))
				$gw = chop(file_get_contents("/tmp/$interface.gw"));

				if (file_exists("/tmp/$interface.ip"))
				$sysalias_rules .= $oc['descr'] . '_IP = "' . $ip . "\"\n";
				if (file_exists("/tmp/$interface.ip") && file_exists("/tmp/$interface.subnet"))
				$sysalias_rules .= $oc['descr'] . '_Network = "' . gen_subnet($ip,$sn) . '/' . $sn . '"' . "\n";
				if (file_exists("/tmp/$interface.gw")) {
					if ($oc['iftype'] == 'wan' && $oc['wantype'] == 'DHCP')
					$sysalias_rules .= $oc['descr'] . '_Gateway = "' . $gw . "\"\n";
				}
			} else {
				$sysalias_rules .= $oc['descr'] . '_IP = "' . $oc['ipaddr'] . "\"\n";
				$sysalias_rules .= $oc['descr'] . '_Network = "' . gen_subnet($oc['ipaddr'],$oc['subnet']) . '"' . "\n";
				if ($oc['iftype'] == 'wan' && $oc['wantype'] == 'Static')
				$sysalias_rules .= $oc['descr'] . '_Gateway = "' . $oc['gateway'] . "\"\n";
			}
		}
	}
	return $sysalias_rules;
}

function filter_system_aliases_names_generate() {
	global $config, $g;

	$lancfg = $config['interfaces']['lan'];

	$optcfg = array();

	for ($i = 1; isset($config['interfaces']['opt' . $i]); $i++) {
		$oc = $config['interfaces']['opt' . $i];

		if (isset($oc['enable']) && $oc['if']) {
			$oic = array();
			$oic['if'] = $oc['if'];

			if ($oc['bridge']) {
				if (!strstr($oc['bridge'], "opt") ||
				isset($config['interfaces'][$oc['bridge']]['enable'])) {
					if (is_ipaddr($config['interfaces'][$oc['bridge']]['ipaddr'])) {
						$oic['ip'] = $config['interfaces'][$oc['bridge']]['ipaddr'];
						$oic['sn'] = $config['interfaces'][$oc['bridge']]['subnet'];
						$oic['sa'] = gen_subnet($oic['ip'], $oic['sn']);
						$oic['descr'] = $config['interfaces'][$oc['bridge']]['descr'];
					}
				}
				$oic['bridge'] = 1;
				$oic['bridge_if'] = $oc['bridge'];
			} else {
				$oic['descr'] = $oc['descr'];
				$oic['ip'] = $oc['ipaddr'];
				$oic['sn'] = $oc['subnet'];
				$oic['sa'] = gen_subnet($oic['ip'], $oic['sn']);
			}

			$optcfg['opt' . $i] = $oic;
		}
	}
	$sysalias_rules = 'RFC_1918 ';
	$sysalias_rules .= 'LAN_IP ';
	$sysalias_rules .= 'LAN_Network ';

	for ($i = 1; isset($optcfg['opt' . $i]); $i++) {
		$sysalias_rules .= $optcfg['opt' . $i]['descr'] . '_IP ';
		$sysalias_rules .= $optcfg['opt' . $i]['descr'] . '_Network ';
	}
	$sysalias_rules = preg_replace("/\ $/", "", $sysalias_rules);
	return $sysalias_rules;
}

function filter_rules_generate() {
	global $config, $g;

	system_determine_hwplatform();

	$wancfg = $config['interfaces']['wan'];
	$lancfg = $config['interfaces']['lan'];
	$lancfg['if'] = $g['hwplatformconfig'][INTERFACES][LAN];
	$wancfg['if'] = $g['hwplatformconfig'][INTERFACES][WAN];
	$pptpdcfg = $config['pptpd'];

	$lanif = $lancfg['if'];
	$wanif = get_real_wan_interface();
	$curwanip = get_current_wan_address();

	/* rule groups (optional interfaces: see below) */
	/*$ifgroups = array("lan" => 100, "wan" => 200);*/

	$lanip = $lancfg['ipaddr'];
	$lansa = gen_subnet($lancfg['ipaddr'], $lancfg['subnet']);
	$lansn = $lancfg['subnet'];

	/* optional interfaces */
	$optcfg = array();

	for ($i = 1; isset($config['interfaces']['opt' . $i]); $i++) {
		$oc = $config['interfaces']['opt' . $i];

		if (isset($oc['enable'])) {
			$oic = array();
			$oic['if'] = $g['hwplatformconfig'][INTERFACES]['OPT' . $i]['IF'];

			if ($oc['bridge']) {
				if (!strstr($oc['bridge'], "opt") ||
				isset($config['interfaces'][$oc['bridge']]['enable'])) {
					if (is_ipaddr($config['interfaces'][$oc['bridge']]['ipaddr'])) {
						$oic['ip'] = $config['interfaces'][$oc['bridge']]['ipaddr'];
						$oic['sn'] = $config['interfaces'][$oc['bridge']]['subnet'];
						$oic['sa'] = gen_subnet($oic['ip'], $oic['sn']);
					}
				}
				$oic['bridge'] = 1;
				$oic['bridge_if'] = $oc['bridge'];
			} else {
				$oic['ip'] = $oc['ipaddr'];
				$oic['sn'] = $oc['subnet'];
				$oic['sa'] = gen_subnet($oic['ip'], $oic['sn']);
			}

			$optcfg['opt' . $i] = $oic;
			/*$ifgroups['opt' . $i] = ($i * 100) + 200;*/
		}
	}

	if ($pptpdcfg['mode'] == "server") {
		$pptpip = $pptpdcfg['localip'];
		$pptpsa = $pptpdcfg['remoteip'];
		$pptpsn = $g['pptp_subnet'];
	}

	/* default block logging? */
	if (isset($config['filter']['options']['logging']['default']))
	$log = 'log ';
	$defaultlog = $log . 'all';
	$ipfrules .= <<<EOD

#######################
#### Blocked Sites ####
#######################
anchor "Abusive_Sites" {
    block log quick from { <static_abusive_sites> } to any
    block log quick from any to { <static_abusive_sites> }
}

#######################
#### Default Policy ###
#######################
anchor "default" {
    block in $defaultlog 
    pass out all

EOD;

	/* If multiwan is enabled do this */
	if (isset($config['system']['advanced']['multiwansupport']) && sg_get_const("ENTERPRISE_ROUTING") == 'ENABLED') {
		$wanifs = filter_generate_multiwan_interfaces();
		foreach($wanifs as $if) {
			$otherwanifs = array();
			foreach($wanifs as $otherwan) {
				if($otherwan != $if) {
					array_push($otherwanifs, $otherwan);
				}
			}
			foreach($otherwanifs as $otherif) {
				$gw = get_interface_gw($otherif);
				if (is_ipaddr($gw))
				$ipfrules .= "\tpass out on $if route-to ($otherif $gw) from $otherif to any\n";
			}
		}
	}


	if($config['interfaces']['opt2']['wireless']['ifmode'] == 'lanbridge' || $config['interfaces']['opt2']['wireless']['ifmode'] == 'dmzbridge') {
		$ipfrules .= <<<EOD

    ##############################################
    ### Allow all traffic into Wireless bridge ###
    ##############################################
    anchor "Wireless_Bridge" {
        pass in quick on ral0 all
    }

EOD;
	} else {
		$ipfrules .= <<<EOD

    #######################################################
    #### Activate spoofing protection on all interfaces ###
    #######################################################
    block in quick from urpf-failed

EOD;
	}

	/* pass traffic between statically routed subnets and the subnet on the
	 interface in question to avoid problems with complicated routing
	 topologies */
	if (is_array($config['staticroutes']['route']) && count($config['staticroutes']['route'])) {
		$ipfrules .= "\n###########################################\n";
		$ipfrules .= "\n### Allow traffic from/to static routes ###\n";
		$ipfrules .= "\n###########################################\n";
		foreach ($config['staticroutes']['route'] as $route) {
			unset($sa);

			if ($route['interface'] == "lan") {
				$ip = $lanip;
				$sa = $lansa;
				$sn = $lansn;
				$if = $lanif;
			} else if (strstr($route['interface'], "opt")) {
				$oc = $optcfg[$route['interface']];
				if ($oc['ip']) {
					$ip = $oc['ip'];
					$sa = $oc['sa'];
					$sn = $oc['sn'];
					$if = $oc['if'];
				}
			}

			if ($sa) {
				$ipfrules .= <<<EOD
    pass in quick on {$if} from {$sa}/{$sn} to {$route['network']}
    pass in quick on {$if} from {$route['network']} to {$sa}/{$sn}
    pass out quick on {$if} from {$sa}/{$sn} to {$route['network']}
    pass out quick on {$if} from {$route['network']} to {$sa}/{$sn}

EOD;
			}
		}
	}
	for ($i = 1; isset($config['interfaces']['opt' . $i]); $i++) {
		$oc = $config['interfaces']['opt' . $i];
		if($oc['wireless']['ifmode'] != 'lanbridge' && $oc['wirelless']['ifmode'] != 'dmzbridge') {
			if($oc['ipaddr'] == 'dhcp') {
				$interface = get_interface_name_by_descr($oc['descr']);
				if (file_exists("/tmp/$interface.ip"))
				$ip = chop(file_get_contents("/tmp/$interface.ip"));
				if (file_exists("/tmp/$interface.subnet"))
				$sn = mask2cidr(chop(file_get_contents("/tmp/$interface.subnet")));
				if (file_exists("/tmp/$interface.ip") && file_exists("/tmp/$interface.subnet")) {
					$subnet = gen_subnet($ip,$sn);
					$ipfrules .= "\tblock in $log quick on $wanif from $subnet/$sn to any\n";
				}
			} else {
				$sn = $oc['subnet'];
				$subnet = gen_subnet($oc['ipaddr'],$sn);
				$ipfrules .= "\tblock in $log quick on $wanif from $subnet/$sn to any\n";
			}
		}
	}

	/* allow PPTP traffic if PPTP client is enabled on WAN */
	if ($wancfg['ipaddr'] == "pptp") {
		$ipfrules .= <<<EOD

    #########################
    ### Allow PPTP client ###
    #########################
    pass in quick on {$wancfg['if']} proto gre from any to any
    pass out quick on {$wancfg['if']} proto gre from any to any
    pass in quick on {$wancfg['if']} proto tcp from any port 1723 to any
    pass out quick on {$wancfg['if']} proto tcp from any to any port 1723

EOD;
	}

	$ipfrules .= <<<EOD

    ########################### 
    ### LAN/OPT spoof check ###
    ###########################
    anchor "spoofed-source" {\n
EOD;
	/* LAN spoof check */
	/* omit if any interface is bridged to LAN and the filtering bridge is on */
	$lanbridge = false;
	for ($i = 1; isset($config['interfaces']['opt' . $i]); $i++) {
		if($config['interfaces']['opt' . $i]['wireless']['ifmode'] == 'lanbridge')
		$lanbridge = true;
	}
	if (!$lanbridge)
	$ipfrules .= "\t\t" . filter_rules_spoofcheck_generate('lan', $lanif, $lansa, $lansn, $log);

	/* OPT spoof check */
	/* omit for bridged interfaces when the filtering bridge is on */
	$isbridged = false;
	for ($i = 1; isset($config['interfaces']['opt' . $i]); $i++) {
		if($config['interfaces']['opt' . $i]['wireless']['ifmode'] == 'lanbridge' || $config['interfaces']['opt' . $i]['wireless']['ifmode'] == 'dmzbridge')
		$isbridged = true;
	}
	if (!$isbridged && isset($config['interfaces']['opt' . $i]['enable']))
	$ipfrules .= filter_rules_spoofcheck_generate($on, $oc['if'], $oc['sa'], $oc['sn'], $log);

	$ipfrules .= "\t}\n";

	/* block private networks on WAN? */
	if (isset($config['interfaces']['wan']['blockpriv'])) {
		$ipfrules .= <<<EOD

    #############################################################
    ### Block anything from private networks on WAN interface ###
    #############################################################
EOD;
		$ipfrules .= "\nanchor \"Block RFC1918\" {\n\tblock in $log quick on $wanif from" . ' $RFC_1918 ' . "to any\n}\n";
	}

	/* IPsec enabled? */
	if (is_array($config['ipsec']['gw'])) {
		/* put a comment of the name for the rdr rule(s) */
		$ipfrules .= "\n";
		$ipfrules .= "\t" . filter_pad_comments("Allow IPSec") . "\n";
		$ipfrules .= "\t" . "### " .  "Allow IPSec" . " ###\n";
		$ipfrules .= "\t" . filter_pad_comments("Allow IPSec") . "\n";
		$ipfrules .= <<<EOD
\tpass in quick proto udp from any to any port {500, 4500}
\tpass in quick proto esp
\tpass in quick proto ah
\tpass in quick on enc0 proto ipencap keep state (if-bound)
EOD;
		foreach($config['ipsec']['gw'] as $gateway) {
			$ipfrules .= filter_rules_ipsec_generate($gateway['srclist'], $gateway['dstlist']);
		}

	}
	/* Webgui antilockout code */
	if (!isset($config['system']['general']['webgui']['noantilockout'])) {
		$webuiport = $config['system']['general']['webgui']['port'];
		if (!$webuiport) {
			$webuiport = '443';
		} else {
			$webuiport = $config['system']['general']['webgui']['port'];
		}
		if(isset($config['system']['general']['sshd']['enabled'])) {
			$sshdport = ', 22';
		}

		$webuiport .= $sshdport;
		$ipfrules .= <<<EOD

    
    ###########################
    ### WebGUI anti-lockout ###
    ###########################
    pass in quick on $lanif proto tcp from $lansa/$lansn to $lanip port { $webuiport }

EOD;
	}


	/* CARP code */
	if (isset($config['carp']['carpenable'])) {
		$ipfrules .= <<<EOD
                            
    ###########################
    ### Allow CARP Protocol ###
    ###########################
EOD;
		if (is_array($config['carp']['virtualhost'])) {
			foreach($config['carp']['virtualhost'] as $virtual) {
				$carpdev = get_interface_name_by_descr($virtual['interface']);
				$ipfrules .= "\n\tpass in quick on $carpdev proto carp";
			}
		}
		$ipfrules .= "\n";
	}

	/* PFSync code */
	if (isset($config['pfsync']['pfsyncenable'])) {
		$ipfrules .= <<<EOD

    #############################
    ### Allow Sync Protocols ###
    #############################
EOD;
		$syncdev = get_interface_name_by_descr($config['pfsync']['interface']);
		$ipfrules .= "\n\tpass in quick on $syncdev proto pfsync from any to 224.0.0.240";
		$ipfrules .= "\n\tpass in quick on $syncdev proto tcp from any to any port www";
		$ipfrules .= "\n\tpass in quick on $syncdev proto udp from any to any port dhcpd-sync";
		$ipfrules .= "\n\tpass in quick on $syncdev proto igmp from any to 224.0.1.240\n";
	}

	/* PPTPd enabled? */
	if ($pptpdcfg['mode'] && ($pptpdcfg['mode'] != "off")) {

		if ($pptpdcfg['mode'] == "server") {
			$pptpdtarget = $curwanip;
		} else {
			$pptpdtarget = $pptpdcfg['redir'];
		}
		if ($pptpdtarget) {
			$ipfrules .= <<<EOD

##################
### PPTP rules ###
##################
pass in quick proto gre from any to $pptpdtarget 
pass in quick proto tcp from any to $pptpdtarget port 1723 
EOD;
		}
	}

	/* BigPond client enabled? */
	if ($wancfg['ipaddr'] == "bigpond") {

		$ipfrules .= <<<EOD

###############################
### BigPond heartbeat rules ###
###############################
pass in quick proto udp from any to any port 5050 

EOD;
	}

	/* End of Default Packet Handling */
	$ipfrules .= "\n}";

	$i = 0;
	$ipfrules .= <<<EOD

##############################
##############################
##### User Defined Rules #####
##############################
##############################
\n\n
EOD;

	if (isset($config['filter']['rule']))
	foreach ($config['filter']['rule'] as $rule) {

		/* does the rule deal with a PPTP interface? */
		if ($rule['interface'] == "pptp") {

			if ($pptpdcfg['mode'] != "server") {
				$i++;
				continue;
			}

			$nif = $g['n_pptp_units'];
			$ispptp = true;
		} else {

			if (strstr($rule['interface'], "opt")) {
				if (!array_key_exists($rule['interface'], $optcfg)) {
					$i++;
					continue;
				}
			}

			$nif = 1;
			$ispptp = false;
		}

		if ($pptpdcfg['mode'] != "server") {
			if (($rule['source']['network'] == "pptp") ||
			($rule['destination']['network'] == "pptp")) {
				$i++;
				continue;
			}
		}

		if ($rule['source']['network'] && strstr($rule['source']['network'], "opt")) {
			if (!array_key_exists($rule['source']['network'], $optcfg)) {
				$i++;
				continue;
			}
		}
		if ($rule['destination']['network'] && strstr($rule['destination']['network'], "opt")) {
			if (!array_key_exists($rule['destination']['network'], $optcfg)) {
				$i++;
				continue;
			}
		}

		/* check for unresolvable aliases */
		if ($rule['source']['address'] && !alias_expand($rule['source']['address'])) {
			$i++;
			continue;
		}
		if ($rule['destination']['address'] && !alias_expand($rule['destination']['address'])) {
			$i++;
			continue;
		}

		for ($iif = 0; $iif < $nif; $iif++) {

			if (!$ispptp) {

				if (!strstr($rule['interface'], "vlan")) {
					$interface = get_interface_name($rule['interface']);
				} else {
					$interface = $rule['interface'];
				}
				if (!$interface) {
					printf("Invalid interface name in rule $i\n");
					break;
				}
			}

			$protocols = array();
			/* determine if rule is to be redirected to a relay */
			$relayrewrite = 'no';
			if(isset($rule['portforward'])) {
				$relayrewrite =  'yes';
			}
			if (isset($rule['dstlist'])) {
				$dstlist = $rule['dstlist'];
				for($i=0;$i<sizeof($dstlist); $i++) {
					$dst = "dst" . "$i";
					if(preg_match('/^relay:/', $dstlist[$dst])) {
						$relayrewrite = 'yes';
						array_push($protocols, "tcp");
					}
				}
			}
			if ($rule['tcplist']) {
				array_push($protocols, "tcp");
			}
			if ($rule['udplist']) {
				array_push($protocols, "udp");
			}
			if ($rule['ipprotos']) {
				array_push($protocols, "ip");
			}
			if (!$rule['tcplist'] && !$rule['udplist'] && !$rule['ipprotos'] && $relayrewrite == 'no') {
				array_push($protocols, "none");
			}

			$line .= filter_pad_comments($rule['name']) . "\n";
			$line .= "### " .  $rule['name'] . " ###\n";
			$line .= filter_pad_comments($rule['name']) . "\n";
			$line .= "anchor \"" . $rule['name'] . "\" {\n";
			foreach($protocols as $proto) {

				$type = $rule['type'];
				if ($type != "pass" && $type != "block" && $type != "reject") {
					/* default (for older rules) is pass */
					$type = "pass";
				}

				if ($type == "reject") {
					/* special reject packet */
					if ($proto == "tcp") {
						$line .= "\tblock return-rst";
					} else if ($proto == "udp") {
						$line .= "\tblock return-icmp(port-unr)";
					} else {
						$line .= "\tblock";
					}
				} else {
					$line .= "\t$type";
				}

				$line .= " in ";

				if (isset($rule['log']))
				$line .= "log ";

				$line .= "quick ";

				if ($ispptp) {
					$line .= "on ng" . ($iif+1) . " ";
				}

				if (!$ispptp) {
					$line .= "on $interface ";
				}

				### Load Balancing code goes here.
				if (isset($config['system']['advanced']['multiwansupport']) && sg_get_const("ENTERPRISE_ROUTING") == 'ENABLED') {
					if(!in_array($interface, $wanifs)) {
						$line .= "route-to \\\n\t{ ";
						if (!isset($rule['options']['multiwan']) || $rule['options']['multiwan'] == 'roundrobin') {
							foreach($wanifs as $if) {
								$gw = get_interface_gw($if);
								if (is_ipaddr($gw))
								$line .= "($if $gw), ";
							}
						} else {
							$if = get_interface_name_by_descr($rule['options']['multiwan']);
							$gw = get_interface_gw($if);
							if (is_ipaddr($gw))
							$line .= "($if $gw) ";
						}
						$line = preg_replace("/\, $/", "", $line);
						$line .= " } round-robin \\\n\t";
					}
				}
				$line .= "inet ";

				if($proto != 'none') {
					$line .= "proto $proto \\\n\t";
				}
				/* source address */
				if ($rule['srclist']['src0'] == 'any') {
					$line .= "from any ";
				} else {
					$line .=  "from <" . $rule['name'] . "_src> ";
				}

				/* rewrite dest of ftp connections to be 127.0.0.1 as they should be rdr'd previously*/
				$ftprewrite = 'no';
				if($rule['tcplist']) {
					foreach($rule['tcplist'] as $tcpport) {
						if($tcpport == '21') {
							$ftprewrite =  'yes';
						}
					}
				}

				/* dest address */
				if ($ftprewrite == 'yes') {
					$line .= " to { 127.0.0.1 } ";
				} elseif ($relayrewrite == 'yes') {
					$line .= " to { ";
					foreach($config['relays']['relay'] as $relay) {
						if ($relay['name'] == $rule['dstrelay']) {
							if ($relay['forward'] == 'nat lookup') {
								$line .= $relay['listenerip'];
							}
						} else {
							$dstlist = $rule['dstlist'];
							for($i=0;$i<sizeof($dstlist); $i++) {
								$dst = "dst" . "$i";
								if (preg_match('/^relay:/', $dstlist[$dst])) {
									$dstlist[$dst] = preg_replace('/^relay:/', '', $dstlist[$dst]);
									if ($relay['name'] == $dstlist[$dst]) {
										if ($relay['forward'] == 'serverpool') {
											$line .= $relay['listenerip'];
										}
									}
								}
							}
						}
					}
					$line .= " }";
				} else {
					/* dest address */
					if ($rule['dstlist']['dst0'] == 'any') {
						$line .= "to any ";
					} else {
						$line .= "to <" . $rule['name'] . "_dst> ";
					}
				}

				/*protocol ports stuff*/
				if ($ftprewrite == 'yes') {
					$line .= "\\\n\tport { 8021 }";
				} elseif ($relayrewrite == 'yes') {
					$line .= " \\\n\tport { ";
					foreach($config['relays']['relay'] as $relay) {
						if ($relay['name'] == $rule['dstrelay']) {
							if ($relay['forward'] == 'nat lookup') {
								$line .= $relay['listenerport'];
							}
						}
						$dstlist = $rule['dstlist'];
						for($i=0;$i<sizeof($dstlist); $i++) {
							$dst = "dst" . "$i";
							if (preg_match('/^relay:/', $dstlist[$dst])) {
								$dstlist[$dst] = preg_replace('/^relay:/', '', $dstlist[$dst]);
								if ($relay['name'] == $dstlist[$dst]) {
									if ($relay['forward'] == 'serverpool') {
										$line .= $relay['listenerport'];
									}
								}
							}
						}
					}
					$line .= " }";
				} else {
					if ($proto == "tcp" || $proto == "udp") {
						$portlist = $rule[$proto . "list"];
						$string = '';
						for($i=0;$i<sizeof($portlist); $i++) {
							$protocol = "$proto" . "$i";
							$string .= "$portlist[$protocol], ";
						}
						$string = preg_replace("/\, $/", "", $string);
						list($ext_port, $int_port) = split('->', $string);
						if(isset($int_port))
						$string = $int_port;
						$line .= "\\\n\tport { $string } ";
					}
				}

				if ($type == "pass") {

					if (isset($rule['options']['state'])) {
						if($rule['options']['state'] != 'none') {
							$line .= " {$rule['options']['state']}";
						}
					}
					$line = preg_replace("/,$/", '', $line);
					$optionsline = " \\\n\t(";
					if (isset($rule['options']['maxstates'])) {
						$optionsline .= "max {$rule['options']['maxstates']}, ";
					}
					if (isset($rule['options']['srctrack'])) {
						if($rule['options']['srctrack'] != 'none') {
							$optionsline .= "source-track {$rule['options']['srctrack']}, ";
						}
					}
					if (isset($rule['options']['maxsrcnodes'])) {
						$optionsline .= "max-src-nodes {$rule['options']['maxsrcnodes']}, ";
					}
					if (isset($rule['options']['maxsrcstates'])) {
						$optionsline .= "max-src-states {$rule['options']['maxsrcstates']}, ";
					}
					if (isset($rule['options']['maxsrcconns'])) {
						$optionsline .= "max-src-conn {$rule['options']['maxsrcconns']}, ";
					}
					if (isset($rule['options']['maxsrcconrateconns']) && isset($rule['options']['maxsrcconrateseconds'])) {
						$optionsline .= "max-src-conn-rate {$rule['options']['maxsrcconrateconns']}/{$rule['options']['maxsrcconrateseconds']}, ";
					}
					if (isset($rule['options']['overload'])) {
						$optionsline .= 'overload <dynamic_blocked_sites> ';
					}
					if (isset($rule['options']['flush'])) {
						$optionsline .= "flush, ";
					}
					if(!preg_match("/\($/", $optionsline)) {
						$optionsline = preg_replace("/, $/", ')', $optionsline);
						$optionsline = preg_replace("/ $/", ')', $optionsline);
						$line .= $optionsline;
					}
					if(isset($config['altq']['enable'])) {
						if (isset($rule['options']['altqbucket'])) {
							$line .= "\\\n\tqueue ( " .  "{$rule['options']['altqbucket']}";
							if (isset($rule['options']['altqlowdelay'])) {
								$line .= ", ackout";
							}
							$line .= " )";
						}
					}
				}

				$line .= "\n";
			}
			$line .= "}\n";
		}
		$i++;
	}
	$ipfrules .= $line;
	$ipfrules .= <<<EOD

##########################
##### System Anchors #####
##########################
anchor "ftp-proxy/*"
anchor "vpn/*" 

EOD;
	if(isset($config['relays']['pfanchor']))
	$ipfrules .= 'anchor "relayd/*"' . "\n";

	return $ipfrules;
}

function filter_rdrrules_generate() {
	global $config, $g;

	system_determine_hwplatform();

	$wancfg = $config['interfaces']['wan'];
	$lancfg = $config['interfaces']['lan'];
	$lancfg['if'] = $g['hwplatformconfig'][INTERFACES][LAN];
	$wancfg['if'] = $g['hwplatformconfig'][INTERFACES][WAN];
	$pptpdcfg = $config['pptpd'];

	$lanif = $lancfg['if'];
	$wanif = get_real_wan_interface();
	$curwanip = get_current_wan_address();

	/* rule groups (optional interfaces: see below) */
	/*$ifgroups = array("lan" => 100, "wan" => 200);*/

	$lanip = $lancfg['ipaddr'];
	$lansa = gen_subnet($lancfg['ipaddr'], $lancfg['subnet']);
	$lansn = $lancfg['subnet'];

	/* optional interfaces */
	$optcfg = array();

	for ($i = 1; isset($config['interfaces']['opt' . $i]); $i++) {
		$oc = $config['interfaces']['opt' . $i];

		if (isset($oc['enable']) && $oc['if']) {
			$oic = array();
			$oic['if'] = $oc['if'];

			if ($oc['bridge']) {
				if (!strstr($oc['bridge'], "opt") ||
				isset($config['interfaces'][$oc['bridge']]['enable'])) {
					if (is_ipaddr($config['interfaces'][$oc['bridge']]['ipaddr'])) {
						$oic['ip'] = $config['interfaces'][$oc['bridge']]['ipaddr'];
						$oic['sn'] = $config['interfaces'][$oc['bridge']]['subnet'];
						$oic['sa'] = gen_subnet($oic['ip'], $oic['sn']);
					}
				}
				$oic['bridge'] = 1;
				$oic['bridge_if'] = $oc['bridge'];
			} else {
				$oic['ip'] = $oc['ipaddr'];
				$oic['sn'] = $oc['subnet'];
				$oic['sa'] = gen_subnet($oic['ip'], $oic['sn']);
			}

			$optcfg['opt' . $i] = $oic;
			/*$ifgroups['opt' . $i] = ($i * 100) + 200;*/
		}
	}

	$ipfrules = "\n#################\n";
	$ipfrules .= "### RDR rules ###\n";
	$ipfrules .= "#################\n";

	/* if we have a rule with dst port 20/21 setup the ftpproxy anchor */
	$i = 0;
	if (isset($config['filter']['rule']))
	foreach ($config['filter']['rule'] as $rule) {

		/* does the rule deal with a PPTP interface? */
		if ($rule['interface'] == "pptp") {

			if ($pptpdcfg['mode'] != "server") {
				$i++;
				continue;
			}

			$nif = $g['n_pptp_units'];
			$ispptp = true;
		} else {

			if (strstr($rule['interface'], "opt")) {
				if (!array_key_exists($rule['interface'], $optcfg)) {
					$i++;
					continue;
				}
			}

			$nif = 1;
			$ispptp = false;
		}
		/* check to see if there are rdr's in this rule */
		$rdrexists = 0;
		$rdrlist = array();
		/* configured snats */
		foreach($rule['dstlist'] as $dstlist) {
			if(preg_match('/^\d+.\d+.\d+.\d+:/', $dstlist)) {
				array_push($rdrlist, $dstlist);
				$rdrexists = 1;
			}
			if(preg_match('/^WAN_IF:/', $dstlist)) {
				array_push($rdrlist, $dstlist);
				$rdrexists = 1;
			}
		}
		/* hijack ftp connections and send them to the proxy */
		if($rule['tcplist']) {
			foreach($rule['tcplist'] as $tcpport) {
				if($tcpport == '21') {
					array_push($rdrlist,'ftp:' . $rule[$dstlist]);
					$rdrexists = 1;
				}
			}
		}
		/* hijack connections user specifies to send to a relay */
		if(isset($rule['portforward'] )) {
			foreach($config['relays']['relay'] as $relay) {
				if ($relay['name'] == $rule['dstrelay']) {
					if($relay['forward'] != 'nat lookup') {
						continue 2;
					}
				}
			}
			array_push($rdrlist,'relay:' . $rule['dstrelay'] . ':' . $rule[$dstlist]);
			$rdrexists = 1;
		}

		if ($rdrexists == 0) {
			$i++;
			continue;
		}
		/* put a comment of the name for the rdr rule(s) */
		$line .= "\n";
		$line .= filter_pad_comments($rule['name']) . "\n";
		$line .= "### " .  $rule['name'] . " ###\n";
		$line .= filter_pad_comments($rule['name']) . "\n";

		foreach($rdrlist as $rdr) {
			if (preg_match('/^\d+.\d+.\d+.\d+:\d+.\d+.\d+.\d+$/', $rdr)) {
				$external = preg_replace('/:\d+.\d+.\d+.\d+$/','', $rdr);
				if (preg_match('/^\d+.\d+.\d+.\d+:/', $rdr)) {
					$internal = preg_replace('/^\d+.\d+.\d+.\d+:/',"", $rdr);
				}
			}
			elseif (preg_match('/^WAN_IF:/', $rdr)) {
				$external = 'WAN_IF';
				$internal = preg_replace('/^WAN_IF:/','', $rdr);
			}
			elseif (preg_match('/^ftp:/', $rdr)) {
				$external = preg_replace('/^ftp"/','', $rdr);
				$internal = '127.0.0.1 port 8021';
			}
			elseif (preg_match('/^relay:/', $rdr)) {
				$relayname = preg_replace('/relay:/','', $rdr);
				$relayname = preg_replace('/:.?$/','', $relayname);
				$rdr = preg_replace('/^.?:/','', $rdr);
				foreach($config['relays']['relay'] as $relay) {
					if ($relay['name'] == $relayname) {

						$external = preg_replace('/^relay:/','', $rdr);
						$internal = $relay['listenerip'] . ' port ' . $relay['listenerport'];
					}
				}
			}
			if (($rule['source']['network'] == "pptp") || ($rule['destination']['network'] == "pptp")) {
				$i++;
				continue;
			}
			for ($iif = 0; $iif < $nif; $iif++) {

				if (!$ispptp) {
					if (!strstr($rule['interface'], "vlan")) {
						$interface = get_interface_name($rule['interface']);
					} else {
						$interface = $rule['interface'];
					}

					if (!$interface) {
						printf("Invalid interface name in rule $i\n");
						break;
					}
				}

				$protocols = array();
				if ($rule['tcplist']) {
					array_push($protocols, "tcp");
				}
				if ($rule['udplist']) {
					array_push($protocols, "udp");
				}
				if ($rule['ipprotos']) {
					array_push($protocols, "ip");
				}
				if (!$rule['tcplist'] && !$rule['udplist'] && !$rule['ipprotos']) {
					array_push($protocols, "none");
				}

				foreach($protocols as $proto) {

					$type = $rule['type'];
					if ($type != "pass" && $type != "block" && $type != "reject") {
						/* default (for older rules) is pass */
					}

					if ($ispptp) {
						$line .= "on ng" . ($iif+1) . " ";
					}

					if (!$ispptp) {
						$line .= "match in on $interface ";
					}

					if($proto != 'none') {
						$line .= "proto $proto \\\n";
					}
					/* source address */
					if ($rule['srclist']['src0'] == 'any') {
						$line .= "from any ";
					} else {
						$line .=  "from <" . $rule['name'] . "_src> ";
					}
					/* dest address */
					if($external == 'WAN_IF') {
						$line .= "to (" . $wanif . ") ";
					} else {
						$line .= "to <" . $rule['name'] . "_dst_ext> ";
					}
					/*protocol ports stuff*/
					if ($proto == "tcp" || $proto == "udp") {
						unset($port_forward);
						$portlist = $rule[$proto . "list"];
						$string = '';
						for($i=0;$i<sizeof($portlist); $i++) {
							$protocol = "$proto" . "$i";
							$string .= "$portlist[$protocol], ";
						}
						$string = preg_replace("/\, $/", "", $string);

						list($ext_port, $int_port) = split('->', $string);
						if($int_port)
						$port_forward = "port $int_port";
						$line .= "\\\nport { $ext_port } rdr-to $internal $port_forward";
					}

					$line .= "\n";
				}
			}
		}
		$i++;
	}
	$ipfrules .= $line;
	return $ipfrules;
}

function filter_rules_spoofcheck_generate($ifname, $if, $sa, $sn, $log) {

	global $g, $config;

	$ipfrules = "";

	$ipfrules .= "block in $log quick on $if from ! $sa/$sn to any\n";

	return $ipfrules;
}

function filter_rules_ipsec_generate($srclist, $dstlist) {
	for($i=0;$i<sizeof($srclist); $i++) {
		$src = "src" . "$i";
		$dst = "dst" . "$i";
		$ipfrules .= "\n\tpass in on enc0 from $dstlist[$dst] to $srclist[$src] keep state (if-bound)";
	}
	return $ipfrules;
}

?>
